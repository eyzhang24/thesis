# Code

This second appendix includes all of the R chunks of code that were hidden throughout the document.

```{r, include = FALSE}
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, size = 'scriptsize')
```

## Code for Chapter \@ref(bayes)

The code for this section generates a toy example, used to demonstrate the kernel machine regression and spline regression techniques. 

```{r}
# load packages
library(tidyverse)
library(stats)
library(splines)
```

```{r}
# set theme for plots
theme_set(theme_light())
theme_update(panel.grid.major = element_blank(), 
             panel.grid.minor = element_blank())
theme_update(
  strip.background = element_rect(color="gray", fill="white"), 
  strip.text = element_text(color = "gray30")
  )
```

```{r}
########
# generate simulated points
########

# generate data from distribution
set.seed(0) # reproducibility
x <- seq(0, 25, length.out = 51)
Y <- exp(x/10) + 2*sin(x/2) + rnorm(51, mean = 0, sd = 0.5)
df <- data.frame(x, Y)

# plot data and linear regression line
q1 <- ggplot(df, aes(x, Y)) +
  geom_point() +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") + 
  geom_smooth(method = "lm", formula = "y~x", 
              color = "deepskyblue3", fill = "gray70", 
              linewidth = 0.5, se = F)

# save plot
ggsave("index/figures/ch3_toy1.png", plot = q1, device = "png", 
       width = 5, height = 3)
```

```{r}
########
# kernel regression
########

# get normal distribution of weights around query points
df$Weight <- dnorm(df$x, mean = 12.5, sd = 1)

# plot points colored by their weights
p1 <- ggplot(df, aes(x, Y)) +
  geom_point(aes(color = Weight)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") + 
  geom_vline(xintercept = 12.5, linetype = "dotted") +
  theme(legend.position = "none")

# plot a curve of weights
normcurv <- data.frame(x = seq(0, 25, length.out = 250)) 
normcurv$Weight <- dnorm(normcurv$x, mean = 12.5, sd = 1)
p2 <- ggplot(normcurv, aes(x, Weight, color = Weight)) +
  geom_line() +
  scale_y_continuous(breaks = c(0, 0.2, 0.4)) +
  theme(legend.position = "none") 

# stitch plots together
q2 <- cowplot::plot_grid(p1, p2, ncol = 1, rel_heights = c(0.7, 0.3))
q2

# save plot
ggsave("index/figures/ch3_toy2.png", plot = q2, device = "png", 
       width = 5, height = 4)

# fit kernel regression with sigma = 1, bandwidth = 8/3
kmr_toy <- ksmooth(df$x, df$Y, kernel = "normal", 
                   bandwidth = 8/3, x.points = df$x)
df <- df |> 
  left_join(as.data.frame(kmr_toy), by = "x") |> 
  rename(Yhat = y)

# plot kernel regression estimation
q3 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhat), color = "deepskyblue3") 
q3

# save plot
ggsave("index/figures/ch3_toy3.png", plot = q3, device = "png", 
       width = 5, height = 3)

# fit kernel regression with sigma = 5, bandwidth = 40/3
kmr_toy_5 <- ksmooth(df$x, df$Y, kernel = "normal", 
                     bandwidth = 40/3, x.points = df$x)

# fit kernel regression with sigma = 0.1, bandwith = 8/30
kmr_toy_1 <- ksmooth(df$x, df$Y, kernel = "normal", 
                     bandwidth = 8/30, x.points = df$x)

# re-join data
dfrho <- df |> 
  left_join(as.data.frame(kmr_toy_5), by = "x") |> 
  rename("rho = 50" = y) |> 
  left_join(as.data.frame(kmr_toy_1), by = "x") |> 
  rename("rho = 0.02" = y) |> 
  select(-Yhat) |> 
  pivot_longer(cols = c("rho = 50", "rho = 0.02"), values_to = "Yhat")

# plot kernel regression with two values of rho
qrho <- ggplot(dfrho) +
  geom_point(aes(x, Y)) +
  geom_line(aes(x, Yhat), color = "deepskyblue3") +
  facet_wrap(~name)
qrho

# save plot
ggsave("index/figures/ch3_toyrho.png", plot = qrho, device = "png", 
       width = 7, height = 3)
```

```{r}
########
# spline regression
########

kn <- c(5, 10, 15, 20) # 4 knots of equal width

# fit linear spline regression
spline_toy_line <- lm(Y ~ bs(x, knots = kn, degree = 1), data = df)
p_line <- predict(spline_toy_line, se = T)
df$Yhats_line <- p_line$fit

q4 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhats_line), color = "deepskyblue3") +
  geom_vline(xintercept = kn, linetype = "dotted")
q4

# save plot
ggsave("index/figures/ch3_toy4.png", plot = q4, device = "png", 
       width = 5, height = 3)

# fit cubic spline regression
spline_toy_cub <- lm(Y ~ bs(x, knots = kn), data = df)
p_cub <- predict(spline_toy_cub, se = T)
df$Yhats_cub <- p_cub$fit

# plot spline regression estimation
q5 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhats_cub), color = "deepskyblue3") +
  geom_vline(xintercept = kn, linetype = "dotted")
q5

# save plot
ggsave("index/figures/ch3_toy5.png", plot = q5, device = "png", 
       width = 5, height = 3)

# fit natural spline regression
spline_toy_nat <- lm(Y ~ ns(x, knots = kn), data = df)
p_nat <- predict(spline_toy_nat, se = T)
df$Yhats_nat <- p_nat$fit

# plot spline regression estimation
q6 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhats_nat), color = "deepskyblue3") +
  geom_vline(xintercept = c(5, 10, 15, 20), linetype = "dotted")
q6

# save plot
ggsave("index/figures/ch3_toy6.png", plot = q6, device = "png", 
       width = 5, height = 3)

# see what happens outside of the bounds
x_longer <- seq(-5, 30, length.out = 81)
y_longer_cub <- predict(spline_toy_cub, 
                        newdata = data.frame(x = x_longer))
y_longer_nat <- predict(spline_toy_nat, 
                        newdata = data.frame(x = x_longer))

df_longer <- data.frame(
  x = c(x_longer, x_longer), 
  spline = c(rep("Cubic", 81), rep("Natural", 81)), 
  Yhat = c(y_longer_cub, y_longer_nat)
)

# plot outside of bounds
qbounds <- ggplot(df_longer) + 
  geom_line(aes(x, Yhat), color = "deepskyblue3") +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_vline(xintercept = c(0, 25), linetype = "dotted") +
  facet_wrap(~spline) 
qbounds

# save plot
ggsave("index/figures/ch3_toybounds.png", plot = qbounds, 
       device = "png", width = 7, height = 3)
```

## Code for Chapter \@ref(methods)

The code for this section prepares the data from the MADRES study, generates simulated data, and fits multiple linear regressions, BKMR, and BSR on the simulated data. 

### Cleaning MADRES data

First, we clean the data from the MADRES study. Note that this code requires two publicly available datasets, available from the HHEAR Data Repository, as outlined in Chapter \@ref(madres). 

```{r}
# load packages
library(tidyverse)
```

```{r}
# read in data
target <- read_csv("madres_data/1945_TARGETED_DATA.csv")
epi <- read_csv("madres_data/1945_EPI_DATA.csv")
```

```{r}
########
# clean target data
########

target_small <- target |> 
  # if below LOD, use LOD / sqrt(2)
  mutate(conc_mod = ifelse(Comment_code == 37, 
                           LOD / sqrt(2), 
                           Concentration)) |> 
  # adjust for urine specific gravity: Ac = A × [(SGmean –1)/(SG–1)]
  mutate(conc_mod = conc_mod * ((mean(target$SG)-1)/(SG-1))) |> 
  select(Project_ID, SID, PID, child_PID, Analyte_Code, conc_mod) |> 
  group_by(SID) |> 
  mutate(Project_ID = min(Project_ID)) |> 
  ungroup() |> 
  pivot_wider(names_from = Analyte_Code, values_from = conc_mod) |> 
  # howe kept As, Cd, Co, Hg, Ni, Tl, and Pb in main, Mo, Sb, and Sn in supp
  # don't have modified version of As used in their paper
  select(Project_ID, SID, PID, child_PID, 
         As, Cd, Co, Hg, Ni, Tl, Pb, Mo, Sb, Sn)

# save
write_csv(target_small, "madres_data/target_small.csv")

# only keep data from first trimester
target_first <- target_small |> 
  group_by(child_PID) |> 
  filter(Project_ID == min(Project_ID)) |> 
  ungroup()

# save
write_csv(target_first, "madres_data/target_first.csv")
```

```{r}
########
# clean epi data
########

# select relevant variables
epi_small <- epi |> 
  # make new categorical variables
  mutate(mom_site = as.factor(mom_site), 
         race = as.factor(case_when(
           t1_demo_hispanic == 0 & t1_demo_race == 2 ~ 1, #non-hisp white
           t1_demo_hispanic == 0 & t1_demo_race == 4 ~ 2, #non-hisp black
           t1_demo_hispanic == 0 ~ 3, #other, non-hispanic
           t1_demo_hispanic == 1 & t1_demo_usa == 1 ~ 4, #hispanic in US
           t1_demo_hispanic == 1 & t1_demo_usa == 0 ~ 5, #hispanic NOT in US
           .default = NA
         )), 
         smoke = as.factor(ifelse(
           t1_smoke_preg == 1 | t2_smoke_preg == 1 | t3_smoke_preg == 1 |
             t1_smoke == 1 | t2_smoke == 1 | t3_smoke == 1, 1, 0
         ))) |> 
  # replace -99 with NA
  mutate(across(where(is.numeric), ~ifelse(. == -99, NA, .)))  |> 
  dplyr::select(child_pid, mom_site, 
                age = t1_mat_age, # age, trimester 1
                bmi = t1_pre_BMI, # bmi
                race, # maternal r/e
                smoke, # ever-exposure to smoke
                gender, birthweight, GA # birthweight + gestational age
                # can't find anemia measure or AsB
  ) 

# handle NA values
epi_imp <- epi_small |> 
  # exclude birthweight (observed response)
  # exclude study site because of small categories
  select(-c(gender, birthweight, GA, mom_site)) |> 
  # na's for smoke during preg, set to 0
  mutate(smoke = as.factor(ifelse(is.na(smoke), 0, smoke))) |> 
  # impute mean for BMI
  mutate(across(where(is.numeric), 
                ~ifelse(is.na(.), mean(.,na.rm = TRUE), .))) 
```

```{r}
########
# combine epi and target data
########
comb <- epi_imp |> 
  left_join(target_first, by = c("child_pid" = "child_PID")) |> 
  relocate(child_pid, Project_ID, SID, PID, mom_site, race, smoke) 

# remove outliers
comb_small <- comb |> 
  filter(Mo >=1, Sb <= 1.4)

# save
write_csv(comb_small, "madres_data/base_data.csv")
```


### Simulating predictor data

Next, we use copulas to simulate predictor data, as described in Chapter \@ref(copula). We use the `copula` and `rslurm` packages in this section. This code was run on FrostByte, the Amherst high-performance computing cluster (HPC) RStudio server. 

```{r}
# load packages
library(tidyverse)
library(copula)
library(rslurm)
```

```{r}
# read data back in
comb_small <- read_csv("madres_data/base_data.csv")

# log-transform target data
comb_log <- comb_small |> 
  mutate(across(10:19, log)) |> 
  # factors back to numeric
  mutate(across(where(is.factor), as.numeric))

# check spearman's rho
cor(comb_log[, 7:19], method = "spearman")
```

```{r}
########
# fit copulas
########

# create pseudo observations for continuous variables
u <- pobs(comb_log[, 7:19])

# fit checkerboard copula on smoke
prop_smoke0 <- 1 - mean(comb_log$smoke)
# jitter 0's and 1's uniformly within quantile
set.seed(0)
u_smoke <- comb_log$smoke |> 
  map_dbl(\(x) {
    ifelse(x == 0, runif(1, 0, prop_smoke0), runif(1, prop_smoke0, 1))
  })
u[, 1] <- u_smoke

# fit copulas
cfit_gaus <- fitCopula(normalCopula(dim = 13, dispstr = "un"), u)
cfit_t1 <- fitCopula(tCopula(dim = 13, dispstr = "un", 
                             df.fixed = FALSE), u)
cfit_t2 <- fitCopula(tCopula(dim = 13, dispstr = "un", 
                             df = 4, df.fixed = TRUE), u)
cfit_t3 <- fitCopula(tCopula(dim = 13, dispstr = "un", 
                             df = 10, df.fixed = TRUE), u)
cfit_gum1 <- fitCopula(gumbelCopula(4, dim = 13), u)
cfit_gum2 <- fitCopula(gumbelCopula(2, dim = 13), u)
cfit_frank1 <- fitCopula(frankCopula(4, dim = 13), u)
cfit_frank2 <- fitCopula(frankCopula(2, dim = 13), u)
cfit_clay1 <- fitCopula(claytonCopula(4, dim = 13), u)
cfit_clay2 <- fitCopula(claytonCopula(2, dim = 13), u)
cfit_joe1 <- fitCopula(joeCopula(4, dim = 13), u)
cfit_joe2 <- fitCopula(joeCopula(2, dim = 13), u)

# evaluate fit using AIC
aic_values <- sapply(list(cfit_gaus, cfit_t1, cfit_t2, cfit_t3, 
                          cfit_gum1, cfit_gum2, cfit_frank1, cfit_frank2, 
                          cfit_clay1, cfit_clay2, cfit_joe1, cfit_joe2
                          ), AIC)
names(aic_values) <- c("cfit_gaus", "cfit_t1", "cfit_t2", "cfit_t3",
                       "cfit_gum", "cfit_gum2", "cfit_frank1", "cfit_frank2", 
                       "cfit_clay1", "cfit_clay2", "cfit_joe1", "cfit_joe2")
sort(aic_values)

# evaluate fit using likelihood
aic_values <- sapply(list(cfit_gaus, cfit_t1, cfit_t2, cfit_t3, 
                          cfit_gum1, cfit_gum2, cfit_frank1, cfit_frank2, 
                          cfit_clay1, cfit_clay2, cfit_joe1, cfit_joe2
                          ), logLik)
names(lik_values) <- c("cfit_gaus", "cfit_t1", "cfit_t2", "cfit_t3",
                       "cfit_gum", "cfit_gum2", "cfit_frank1", "cfit_frank2", 
                       "cfit_clay1", "cfit_clay2", "cfit_joe1", "cfit_joe2")
sort(lik_values)

# guassian copula performs best, proceed with this
write_rds(cfit_gaus, "sim/gauscop.RDS")
```

```{r}
########
# simulate predictor data
########

# read copula back in 
cfit_gaus <- read_rds("sim/gauscop.RDS")

# extract rho 
rho <- coef(cfit_gaus)

# create function for simulation
simulate_data <- function(data, n, rho, prop_smoke, prop_race) {
  #' data = original observed data
  #' n = sample size
  #' rho = rho values from normal copula
  #' prop_smoke = proportion smoke from observed dataset
  #' prop_race = table with race/eth values
  
  # simulate pseudo-observations from copula
  samp <- rCopula(n, normalCopula(rho, dim = ncol(data), dispstr = "un"))
  
  # transform pseudo-observations to observed marginal distributions
  sampt <- 1:ncol(data) |> 
    purrr::map_dfc(
      \(x) {
        if(names(data)[x] == "smoke") {
          # use observed probability threshold for smoke
          df <- data.frame(ifelse(samp[,x] < prop_smoke, 0, 1), 
                           row.names = NULL)
        } else {
          # use empirical marginal CDF's for continuous
          df <- data.frame(quantile(data[[x]], probs = samp[,x]), 
                           row.names = NULL)
        }
        names(df) <- names(data)[x]
        return(df)
      }
    ) |> 
    # randomly sample race
    mutate(race = sample(x = names(prop_race), prob = prop_race,
                         size = n, replace = T)) |> 
    relocate(race)
  return(sampt)
}

# create function to run size 252 samples on hpc
run_sim1 <- function() {
  set.seed(0)
  out <- 1:2100 |> 
    purrr::map(\(x) {
      mutate(simulate_data(comb_log_clip, n = nrow(comb_log_clip), rho = rho, 
                           prop_smoke = 1-mean(comb_log_clip$smoke), 
                           prop_race = table(comb_log$race)), 
             race = as.numeric(race), 
             sim = x) 
    })
  return(out)
}

# send job to hpc for size 252 samples
sjob1 <- slurm_call(run_sim1, 
                    global_objects = c('comb_log', 'comb_log_clip', 
                                       'rho', 'simulate_data'),
                    jobname = 'sim_data1')

# get output
out1 <- get_slurm_out(sjob1)
write_rds(out1, "sim/sim_preds_sm.RDS")

# create function to run size 1000 samples on hpc
run_sim2 <- function() {
  set.seed(1)
  out <- 1:2100 |> 
    purrr::map(\(x) {
      mutate(simulate_data(comb_log_clip, n = 1000, rho = rho, 
                           prop_smoke = 1-mean(comb_log_clip$smoke), 
                           prop_race = table(comb_log$race)), 
             race = as.numeric(race), 
             sim = x)
    })
  return(out)
}

# send job to hpc for size 1000 samples
sjob2 <- slurm_call(run_sim2, 
                    global_objects = c('comb_log', 'comb_log_clip', 
                                       'rho', 'simulate_data'),
                    jobname = 'sim_data2')

# get output
out2 <- get_slurm_out(sjob2)
write_rds(out2, "sim/sim_preds_lg.RDS")
```

Here, we visualize the observed and simulated predictor data. 

```{r}
# load packages
library(tidyverse)
library(latex2exp) # for printing latex on ggplot

# set theme for plots
theme_set(theme_light())
theme_update(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
theme_update(
  strip.background = element_rect(color="gray", fill="white"), 
  strip.text = element_text(color = "gray30")
)
```

```{r}
########
# observed data
########

# read target data back in
target_first <- read_csv("madres_data/target_first.csv")

# create spearman's correlation matrix
cor_mat <- cor(target_first[, 5:14], method = "spearman")
cor_mat[lower.tri(cor_mat)] <- NA

# reshape correlation matrix to longer format
melt_cor <- reshape2::melt(cor_mat) |> 
  mutate(label = ifelse(value == 1, NA, round(value, 2))) |> 
  na.omit()

# create correlation heatmap
cor_orig <- melt_cor |> 
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = label), size = 3.5) +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  coord_fixed() +
  labs(x = NULL, y = NULL, fill = TeX(r"( Spearman's $\rho$ )")) +
  theme(
    panel.grid.major.x = element_line(color = "grey85",
                                      linewidth = 0.25,
                                      linetype = 2), 
    panel.border = element_blank(),
    legend.justification = c(1, 0),
    legend.position = c(0.9, 0.1),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))
cor_orig

ggsave("index/figures/ch4_corr.png", width = 5, height = 5)
```


```{r}
# read target and epi data back in
comb_small <- read_csv("madres_data/base_data.csv")

# log-transform target data
comb_log <- comb_small |> 
  mutate(across(10:19, log)) |> 
  # factors back to numeric
  mutate(across(where(is.factor), as.numeric))

# look at densities of exposures before log-transform
univ1 <- comb_small |> 
  select(10:19) |> 
  pivot_longer(cols = 1:10) |> 
  mutate(name = factor(name, levels = names(comb_small)[10:19])) |> 
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(~name, scales = "free", nrow = 2) +
  labs(x = "Concentration (ng/mL)")
# look at densities of exposures after log-transform
univ2 <- comb_log |> 
  select(10:19) |> 
  pivot_longer(cols = 1:10) |> 
  mutate(name = factor(name, levels = names(comb_small)[10:19])) |> 
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(~name, scales = "free", nrow = 2) +
  labs(x = "Natural log concentration (log(ng/mL))")

# plot in grid and save
cowplot::plot_grid(univ1, univ2, labels = "auto", nrow = 2)
ggsave("index/figures/ch4_univlog.png", width = 7.5, height = 5)
```


```{r}
# density plot of continuous covariates
cov_cont <- comb_log |> 
  select(age, bmi) |> 
  pivot_longer(cols = 1:2) |> 
  ggplot(aes(x = value)) +
  geom_density() + 
  facet_wrap(~name, scales = "free", ncol = 1) 

# create new dataset for dist. of categorical covariates
df_forcovcat <- comb_log |> 
  select(smoke, race) |> 
  mutate(smoke = ifelse(smoke == 0, "Never-exposed", "Ever-exposed"), 
         race = case_when(
           race == 1 ~ "Non-Hisp. white", 
           race == 2 ~ "Non-Hisp. black", 
           race == 3 ~ "Non-Hisp. other", 
           race == 4 ~ "Hispanic born\nin US", 
           race == 5 ~ "Hispanic born\noutside US"
         )) |> 
  pivot_longer(cols = 1:2) |> 
  mutate(value = factor(
    value, levels = rev(c("Never-exposed", "Ever-exposed",
                      "Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
                      "Hispanic born\nin US", "Hispanic born\noutside US"))
  )) 

# bar plot of categorical covariates
cov_cat <- df_forcovcat |> 
  ggplot(aes(x = value)) +
  geom_bar(stat = "count", fill = "gray") +
  geom_text(aes(label = after_stat(count)), stat = "count", 
             size = 3, hjust = 1, nudge_y = -2) +
  facet_wrap(~name, scales = "free", ncol = 1) +
  coord_flip() +
  labs(x = NULL)

# plot and save
cowplot::plot_grid(cov_cont, cov_cat, labels = "auto", nrow = 1, 
                   rel_widths = c(0.4, 0.6))
ggsave("index/figures/ch4_covdist.png", width = 6, height = 4)
```

```{r}
#look at association between race and chemicals
name_order <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")
comb_log |> 
  select(c(6, 10:19)) |> 
  pivot_longer(cols = 2:11, names_to = "key", values_to = "value") |> 
  mutate(key = factor(key, levels = name_order)) |> 
  mutate(race = as.factor(race)) |> 
  ggplot(aes(x = race, y = value, color = race)) +
  geom_boxplot() +
  scale_color_discrete(
    name = "Race by ethnicity\nand birth place", 
    labels = c("Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
               "Hispanic born\nin US", "Hispanic born\noutside US")) + 
  theme(legend.spacing.y = unit(0.25, 'cm')) +
  guides(color = guide_legend(byrow = TRUE)) +
  labs(x = "Race, coded", y = "Log concentration") +
  facet_wrap(~key, scales = "free_y")

# save
ggsave("index/figures/ch4_race_exp.png", width = 7, height = 3.5)
```


```{r}
########
# look at simulated data, smaller size
########

# read smaller size simulation back in
out1 <- read_rds("sim/sim_preds_sm.RDS")
comb_sim1 <- bind_rows(out1)

# density plots for exposures
name_order <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")
comb_sim1 |> 
  mutate(sim = as.factor(sim)) |> 
  select(5:15) |> 
  pivot_longer(cols = 1:10) |>
  mutate(name = factor(name, levels = name_order)) |> 
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  # reference density from observed data
  geom_density(
    data = comb_log |> select(10:19) |> pivot_longer(cols = 1:10) |> 
      mutate(name = factor(name, levels = name_order)),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free")
# save
ggsave("index/figures/ch4_univ_exp_sim.png", width = 6, height = 4)
```

```{r}
# density plot for continuous covariates
cov_sim_p <- comb_sim1 |> 
  mutate(sim = as.factor(sim)) |> 
  select(age, bmi, sim) |> 
  pivot_longer(cols = 1:2) |>
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  geom_density(
    data = comb_log |> select(age, bmi) |> pivot_longer(cols = 1:2),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free", ncol = 1)

# bar + violin plot for categorical covariates
cov_sim_q <- comb_sim1 |> 
  mutate(sim = as.factor(sim)) |> 
  select(sim, smoke, race) |> 
  mutate(smoke = ifelse(smoke == 0, "Never-exposed", "Ever-exposed"), 
         race = case_when(
           race == 1 ~ "Non-Hisp. white", 
           race == 2 ~ "Non-Hisp. black", 
           race == 3 ~ "Non-Hisp. other", 
           race == 4 ~ "Hispanic born\nin US", 
           race == 5 ~ "Hispanic born\noutside US"
         )) |> 
  pivot_longer(cols = 2:3) |> 
  group_by(sim, name, value) |> 
  summarize(count = n()) |> 
  mutate(value = factor(
    value, levels = rev(c("Never-exposed", "Ever-exposed",
                          "Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
                          "Hispanic born\nin US", "Hispanic born\noutside US"))
  )) |> 
  ggplot(aes(x = value, y = count)) +
  geom_bar(data = df_forcovcat, aes(x = value), inherit.aes = FALSE,
           stat = "count", fill = "skyblue") +
  geom_violin(color = "gray30", fill = "gray", alpha = 0.25) + 
  facet_wrap(~name, scales = "free", ncol = 1) +
  coord_flip() +
  labs(x = NULL)

# plot in grid and save
cowplot::plot_grid(cov_sim_p, cov_sim_q, labels = "auto", nrow = 1, 
                   rel_widths = c(0.4, 0.6))
  
ggsave("index/figures/ch4_univ_cov_sim.png", width = 6, height = 4)
```

```{r}
# look at correlation structure

# extract correlation structure from simulated data
cors <- out1 |> 
  purrr::map_df(\(x) {
    cor_mat <- cor(x[, 5:14], method = "spearman")
    cor_mat[lower.tri(cor_mat)] <- NA
    melt_cor <- reshape2::melt(cor_mat) |> 
      mutate(value = ifelse(value == 1, NA, value)) |> 
      na.omit() |> 
      mutate(sim = x$sim[1])
    return(melt_cor)
  })

# correlation heatmap of average correlation in simulated data
cor_sim <- cors |> 
  group_by(Var1, Var2) |> 
  summarize(value = mean(value)) |> 
  mutate(label = round(value, 2)) |> 
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = label), size = 3.5) +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  coord_fixed() +
  labs(x = NULL, y = NULL, fill = TeX(r"( Mean Spearman's $\rho$ )")) +
  theme(
    panel.grid.major.x = element_line(color = "grey85",
                                      linewidth = 0.25,
                                      linetype = 2), 
    panel.border = element_blank(),
    legend.justification = c(1, 0),
    legend.position = c(0.9, 0.1),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))

# plot and save
cor_sim
ggsave("index/figures/ch4_corr_avg_sim.png", width = 5, height = 5)

# put original and simulated correlation heatmaps together
top_row <- cowplot::plot_grid(cor_orig, cor_sim, labels = "auto", label_size = 16, 
                   nrow = 1, scale = 0.95)
top_row
ggsave("index/figures/ch4_corr_sim+orig.png", width = 10, height = 5)
```


### Simulating response data

Next, we simulate the response data, as described in Chapter \@ref(simresp. We use the `rslurm` package in this section. This code was run on the Amherst HPC RStudio server. 

```{r}
# load packages
library(tidyverse)
library(rslurm)
```


```{r}
##############
# create functions for various response variables
##############

# base case, no interactions
base_case <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, mult, small
am1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.35*Hg*Ni + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, mult, large
am2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.7*Hg*Ni + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, poly, small
ap1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.13*Hg*((Ni-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, poly, large
ap2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.26*Hg*((Ni-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, mult, small
bm1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.35*Cd*As + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, mult, large
bm2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.7*Cd*As + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, poly, small
bp1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.125*Cd*((As-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, poly, large
bp2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.25*Cd*((As-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, mult, small
cm1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.3*Hg*Co + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, mult, large
cm2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.6*Hg*Co + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, poly, small
cp1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.15*Hg*((Co-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, poly, large
cp2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.3*Hg*((Co-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, multi, small
dm1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.3*Hg*Ni*Tl + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, multi, large
dm2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.6*Hg*Ni*Tl + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, poly, small
dp1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.09*Hg*((Ni-1)^2)*Tl +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, poly, large
dp2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.18*Hg*((Ni-1)^2)*Tl +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}
```

```{r}
#############
# create response variables for exposure-exposure interxn
#############

# read output back in, size 252
out1 <- read_rds("sim/sim_preds_sm.RDS")

# create function for responses at size 252
run_resp1 <- function() {
  set.seed(0)
  out1_resp1 <- out1 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1] 
      x <- x |> 
        # scale log-transformed exposures and covariates
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 100 ~ base_case(x), 
        no <= 200 ~ am1(x), 
        no <= 300 ~ am2(x), 
        no <= 400 ~ ap1(x), 
        no <= 500 ~ ap2(x), 
        no <= 600 ~ bm1(x), 
        no <= 700 ~ bm2(x), 
        no <= 800 ~ bp1(x), 
        no <= 900 ~ bp2(x), 
        no <= 1000 ~ cm1(x), 
        no <= 1100 ~ cm2(x), 
        no <= 1200 ~ cp1(x), 
        no <= 1300 ~ cp2(x), 
        no <= 1400 ~ dm1(x), 
        no <= 1500 ~ dm2(x), 
        no <= 1600 ~ dp1(x), 
        no <= 1700 ~ dp2(x), 
        .default = x #note 1701 - 2100 is for cov-exp interxn
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("_base", 100), 
      rep("am1", 100), 
      rep("am2", 100), 
      rep("ap1", 100), 
      rep("ap2", 100), 
      rep("bm1", 100), 
      rep("bm2", 100), 
      rep("bp1", 100), 
      rep("bp2", 100), 
      rep("cm1", 100), 
      rep("cm2", 100), 
      rep("cp1", 100), 
      rep("cp2", 100), 
      rep("dm1", 100), 
      rep("dm2", 100), 
      rep("dp1", 100), 
      rep("dp2", 100), 
      rep("unset", 400)
    )) 
  return(out1_resp1)
}

# run to hpc
runrespsm <- slurm_call(
  run_resp1, 
  global_objects = c('out1', 'base_case', 
                     'am1', 'am2', 'ap1', 'ap2', 
                     'bm1', 'bm2', 'bp1', 'bp2', 
                     'cm1', 'cm2', 'cp1', 'cp2', 
                     'dm1', 'dm2', 'dp1', 'dp2'),
  jobname = 'sim_resp1')

# get output
out1_resp1 <- get_slurm_out(runrespsm)
# only save for exp-exp interxns
out1_resp1 <- out1_resp1[1:1700]
write_rds(out1_resp1, "sim/sim_resp_sm_a.RDS")

# read output back in, size 1000
out2 <- read_rds("sim/sim_preds_lg.RDS")

# create function for response at size 1000
run_resp2 <- function() {
  set.seed(0)
  out2_resp1 <- out2 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1]
      x <- x |> 
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 100 ~ base_case(x), 
        no <= 200 ~ am1(x), 
        no <= 300 ~ am2(x), 
        no <= 400 ~ ap1(x), 
        no <= 500 ~ ap2(x), 
        no <= 600 ~ bm1(x), 
        no <= 700 ~ bm2(x), 
        no <= 800 ~ bp1(x), 
        no <= 900 ~ bp2(x), 
        no <= 1000 ~ cm1(x), 
        no <= 1100 ~ cm2(x), 
        no <= 1200 ~ cp1(x), 
        no <= 1300 ~ cp2(x), 
        no <= 1400 ~ dm1(x), 
        no <= 1500 ~ dm2(x), 
        no <= 1600 ~ dp1(x), 
        no <= 1700 ~ dp2(x), 
        .default = x #note 1701 - 2100 is for cov-exp interxn
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("_base", 100), 
      rep("am1", 100), 
      rep("am2", 100), 
      rep("ap1", 100), 
      rep("ap2", 100), 
      rep("bm1", 100), 
      rep("bm2", 100), 
      rep("bp1", 100), 
      rep("bp2", 100), 
      rep("cm1", 100), 
      rep("cm2", 100), 
      rep("cp1", 100), 
      rep("cp2", 100), 
      rep("dm1", 100), 
      rep("dm2", 100), 
      rep("dp1", 100), 
      rep("dp2", 100), 
      rep("unset", 400)
    ))
  return(out2_resp1)
}

# send to HPC
runresplg <- slurm_call(
  run_resp2, 
  global_objects = c('out2', 'base_case', 
                     'am1', 'am2', 'ap1', 'ap2', 
                     'bm1', 'bm2', 'bp1', 'bp2', 
                     'cm1', 'cm2', 'cp1', 'cp2', 
                     'dm1', 'dm2', 'dp1', 'dp2'),
  jobname = 'sim_resp2')

# get output
out2_resp1 <- get_slurm_out(runresplg)
# only save output for exp-exp interxns for now
out2_resp1 <- out2_resp1[1:1700]
write_rds(out2_resp1, "sim/sim_resp_lg_a.RDS")
```


```{r}
#############
# create response variables for exposure-covariate interxn
#############

# functions for creating response
# interxn in smaller group, smaller effect size
em1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5 + 0.5*Hg, # 1.5x in group 2
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# interxn in smaller group, larger effect size
em2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5 + Hg, # double in group 2
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# interxn in larger group, smaller effect size
ep1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5 + 0.5*Hg) + # 1.5x in group 5
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# interxn in larger group, larger effect size
ep2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5 + Hg) + # double in group 5
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# read output back in, size 252
out1 <- read_rds("sim/sim_preds_sm.RDS")

# create function to simulate response for smaller size
run_resp1_re <- function() {
  set.seed(0)
  out1_resp1 <- out1 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1] 
      x <- x |> 
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 1700 ~ x, #note 1 - 1700 are chemxchem
        no <= 1800 ~ em1(x), 
        no <= 1900 ~ em2(x), 
        no <= 2000 ~ ep1(x), 
        no <= 2100 ~ ep2(x), 
        .default = x 
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("unset", 1700), 
      rep("em1", 100), 
      rep("em2", 100), 
      rep("ep1", 100), 
      rep("ep2", 100)
    )) 
  return(out1_resp1)
}

# send to HPC
runrespsm_re <- slurm_call(
  run_resp1_re, 
  global_objects = c('out1', 
                     'em1', 'em2', 'ep1', 'ep2'),
  jobname = 'sim_resp1_re')

# get output
out1_resp1_re <- get_slurm_out(runrespsm_re)
out1_resp1_re <- out1_resp1_re[1701:2100]
write_rds(out1_resp1_re, "sim/sim_resp_sm_re.RDS")

# read output back in, size 1000
out2 <- read_rds("sim/sim_preds_lg.RDS")

# create function to simulate response for larger size
run_resp2_re <- function() {
  set.seed(0)
  out2_resp1 <- out2 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1] 
      x <- x |> 
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 1700 ~ x, #note 1 - 1700 are chemxchem
        no <= 1800 ~ em1(x), 
        no <= 1900 ~ em2(x), 
        no <= 2000 ~ ep1(x), 
        no <= 2100 ~ ep2(x), 
        .default = x 
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("unset", 1700), 
      rep("em1", 100), 
      rep("em2", 100), 
      rep("ep1", 100), 
      rep("ep2", 100)
    )) 
  return(out2_resp1)
}

# send to HPC
runresplg_re <- slurm_call(
  run_resp2_re, 
  global_objects = c('out2', 
                     'em1', 'em2', 'ep1', 'ep2'),
  jobname = 'sim_resp2_re')

# get output
out2_resp1_re <- get_slurm_out(runresplg_re)
out2_resp1_re <- out2_resp1_re[1701:2100]
write_rds(out2_resp1_re, "sim/sim_resp_lg_re.RDS")
```

### Fitting models

Here, we fit the models to our simulated data, as described in Chapter \@ref(models). We use the `rslurm`, `bkmr`, and `NLinteraction` packages in this section. This code was run on the Amherst HPC RStudio server. 

```{r}
# load packages 
library(tidyverse)
library(bkmr)
library(NLinteraction)
```

First, we fit the naive and oracle MLRs.

```{r}
#########
# naive and oracle MLRs 
#########

### smaller size

# read in simulated data
out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

run_mlr_sm <- function() {
  # initialize vectors
  mlrs <- vector(mode='list', length = 1700)
  names(mlrs) <- names(out1_resp1)
  mlrtimes <- vector(mode = 'list', length = 1700)
  names(mlrtimes) <- names(out1_resp1)
  
  oracles <- vector(mode='list', length = 1700)
  names(oracles) <- names(out1_resp1)
  oracletimes <- vector(mode = 'list', length = 1700)
  names(oracletimes) <- names(out1_resp1)
  
  for(i in 1:1700) {
    df <- out1_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    start.time <- Sys.time()
    mlrs[[i]] <- lm(y ~ ., data = df)
    end.time <- Sys.time()
    mlrtimes[[i]] <- end.time - start.time
    
    if(i <= 100) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 300) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg*Ni + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 500) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 700) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Cd*As + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 900) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Cd*((As-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1100) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Ni*Co + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1300) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Ni*((Co-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1500) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg:Ni:Tl + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1700) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)*Tl) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    }
  }
  return(list(mlrs, mlrtimes, oracles, oracletimes))
}

# send to hpc
sjob5 <- slurm_call(
  run_mlr_sm, 
  global_objects = c('out1_resp1'),
  jobname = 'mlr_sm')

# get output
mlr_sm <- get_slurm_out(sjob5)
mlr_mods <- mlr_sm[[1]]
mlr_times <- mlr_sm[[2]]
oracle_mods <- mlr_sm[[3]]
oracle_times <- mlr_sm[[4]]
write_rds(mlr_mods, "sim/mlr_mods_sm.RDS")
write_rds(mlr_times, "sim/mlr_mods_sm_times.RDS")
write_rds(oracle_mods, "sim/oracle_mods_sm.RDS")
write_rds(oracle_times, "sim/oracle_mods_sm_times.RDS")

### larger sample size

# read in simulated data
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_mlr_lg <- function() {
  # initialize vectors
  mlrl <- vector(mode='list', length = 1700)
  names(mlrl) <- names(out2_resp1)
  mlrtimel <- vector(mode = 'list', length = 1700)
  names(mlrtimel) <- names(out2_resp1)
  
  oraclel <- vector(mode='list', length = 1700)
  names(oraclel) <- names(out2_resp1)
  oracletimel <- vector(mode = 'list', length = 1700)
  names(oracletimel) <- names(out2_resp1)
  
  for(i in 1:1700) {
    df <- out2_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    start.time <- Sys.time()
    mlrl[[i]] <- lm(y ~ ., data = df)
    end.time <- Sys.time()
    mlrtimel[[i]] <- end.time - start.time
    
    if(i <= 100) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 300) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg*Ni + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 500) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 700) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Cd*As + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 900) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Cd*((As-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1100) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Ni*Co + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1300) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Ni*((Co-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1500) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg:Ni:Tl + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1700) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)*Tl) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    }
  }
  return(list(mlrl, mlrtimel, oraclel, oracletimel))
}

# send to hpc
sjob6 <- slurm_call(
  run_mlr_lg, 
  global_objects = c('out2_resp1'),
  jobname = 'mlr_lg')

# get output
mlr_lg <- get_slurm_out(sjob6)
mlr_modl <- mlr_lg[[1]]
mlr_timel <- mlr_lg[[2]]
oracle_modl <- mlr_lg[[3]]
oracle_timel <- mlr_lg[[4]]
write_rds(mlr_modl, "sim/mlr_mods_lg.RDS")
write_rds(mlr_timel, "sim/mlr_mods_lg_times.RDS")
write_rds(oracle_modl, "sim/oracle_mods_lg.RDS")
write_rds(oracle_timel, "sim/oracle_mods_lg_times.RDS")
```


Next, we fit BKMR and BSR models with the base case and with interactions between chemicals. 

```{r}
#########
# run bkmr
#########

### smaller sample size

out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

run_bkmr_sm <- function(vector) {
  # initiate vector of times
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # for each simulated dataset...
  for(i in vector) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out1_resp1[[i]]
    Z <- df |> 
      select(As:Sn)
    X <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi)
    y <- df$y
    
    # fit model and save time
    set.seed(0)
    start.time <- Sys.time()
    mod <- kmbayes(y = y, Z = Z, X = X, 
                          iter = 50000, verbose = FALSE, varsel = TRUE)
    end.time <- Sys.time()
    bkmr_times[[i]] <- end.time - start.time
    
    # save model and remove from memory
    write_rds(mod, file = paste0("mods/bkmr_sm_", names(out1_resp1)[i], "_", i, ".RDS"))
    write_rds(bkmr_times[[i]], file = 
                paste0("times/bkmr_sm_", names(out1_resp1)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # save times
  write_rds(bkmr_times, file = "bkmr_sm_times.RDS")
}

# send all simulated datasets to hpc
for(i in seq(1, 1601, by = 100)) {
  slurm_call(
    run_bkmr_sm,
    params = list(vector = i:(i+99)),
    global_objects = c('out1_resp1'),
    jobname = paste0("bkmr_sm", str_pad(ceiling(i/100), 2, pad = "0")),
    slurm_options = list(mem = '8G')
  )
}
```

```{r}
### larger sample size
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_bkmr_lg <- function(vector) {
  # initiate vector of times
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes this code would stop prematurely...
  # so this chunk finds the index of the last model that was run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", list_files))
  print(nums)
  if(length(nums) == 0) {
    final <- 0; starting <- min(vector)
  } else {
    final <- max(nums); starting <- final + 1
  }
  # keep note of when the loop was stopped and re-started
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  # for each simulated dataset...
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out2_resp1[[i]]
    Z <- df |> 
      select(As:Sn)
    X <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi)
    y <- df$y
    knots <- fields::cover.design(Z, nd = 100)$design
    
    # fit model and save time
    set.seed(0)
    start.time <- Sys.time()
    mod <- kmbayes(y = y, Z = Z, X = X, knots = knots,
                   iter = 50000, verbose = FALSE, varsel = TRUE)
    end.time <- Sys.time()
    bkmr_times[[i]] <- end.time - start.time
    
    # save model and remove from memory
    write_rds(mod, file = paste0("mods/bkmr_lg_", names(out2_resp1)[i], "_", i, ".RDS"))
    write_rds(bkmr_times[[i]], file = 
                paste0("times/bkmr_lg_", names(out2_resp1)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # save times
  write_rds(bkmr_times, file = "bkmr_lg_times.RDS")
}

# send all simulated datasets to hpc
for(i in seq(1, 1601, by = 100)) {
  slurm_call(
    run_bkmr_lg,
    params = list(vector = i:(i+99)),
    global_objects = c('out2_resp1'),
    jobname = paste0("bkmr_lg", str_pad(ceiling(i/100), 2, pad = "0")),
    slurm_options = list(mem = '8G')
  )
}
```

```{r}
########
# run bsr
########

### smaller sample size

out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

run_bsr_sm <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes this code would stop prematurely...
  # so this chunk finds the index of the last model that was run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0; starting <- min(vector)
  } else {
    final <- max(nums); starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  # for each simulated dataset...
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out1_resp1[[i]]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # fit model for d = {1, 2, 3, 4, 5} and save time
    list_times <- vector(mode = "list", length = 2)
    
    set.seed(0)
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    print(paste0("-------- chose ", ind, " -----------"))
    
    # fit with selected d from waic
    start.time <- Sys.time()
    mod <- NLint(Y = Y, X = X, C = C, 
                 nIter = 50000, nBurn = 25000, ns = ind)
    end.time <- Sys.time()
    list_times[[2]] <- end.time - start.time
    
    bsr_times[[i]] <- list_times
    
    # save model and remove from memory
    write_rds(mod, file = 
                paste0("mods/bsr_sm_", names(out1_resp1)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                 paste0("times/bsr_sm_", names(out1_resp1)[i], "_", i, 
                        "df", ind, ".RDS"))
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  write_rds(bsr_times, file = "bsr_smf_times.RDS")
  return(bsr_times)
}

# send all simulated datasets to hpc
for(i in seq(1, 1601, by = 100)) {
  slurm_call(
    run_bsr_lg,
    params = list(vector = i:(i+99)),
    global_objects = c('out1_resp1'),
    jobname = paste0("bsr_sm", str_pad(ceiling(i/100), 2, pad = "0")),
    slurm_options = list(mem = '8G')
  )
}
```

```{r}
### larger sample size

out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_bsr_lg <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes this code would stop prematurely...
  # so this chunk finds the index of the last model that was run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0; starting <- min(vector)
  } else {
    final <- max(nums); starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out2_resp1[[i]]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # fit model for d = {1, 2, 3, 4, 5} and save time
    list_times <- vector(mode = "list", length = 2)
    
    set.seed(0)
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    print(paste0("-------- chose ", ind, " -----------"))
    
    start.time <- Sys.time()
    mod <- NLint(Y = Y, X = X, C = C, 
                 nIter = 50000, nBurn = 25000, ns = ind)
    end.time <- Sys.time()
    list_times[[2]] <- end.time - start.time
    
    bsr_times[[i]] <- list_times
    
    # save model and remove from memory
    write_rds(mod, file = 
                paste0("mods/bsr_lgf_", names(out2_resp1)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bsr_lgf_", names(out2_resp1)[i], "_", i, 
                       "df", ind, ".RDS"))
    
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  write_rds(bsr_times, file = "bsr_lgf_times.RDS")
  # return(bsr_times)
}

# send all simulated datasets to hpc
for(i in seq(1, 1601, by = 100)) {
  slurm_call(
    run_bsr_sm,
    params = list(vector = i:(i+99)),
    global_objects = c('out2_resp1'),
    jobname = paste0("bsr_lg", str_pad(ceiling(i/100), 2, pad = "0")),
    slurm_options = list(mem = '8G')
  )
}
```

Next, we fit stratified models with an interaction between the categorical race variable and a chemical. 

```{r}
##########
# stratified bkmr, smaller size
##########

out1_resp1_re <- read_rds("sim/sim_resp_sm_re.RDS")

run_bkmr_sm_re <- function(vector) {
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  for(i in vector) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out1_resp1_re[[i]]
    
    # for each race level, run bmkr
    list_times <- vector(mod = "list", length = 6)
    list_mods <- vector(mod = "list", length = 6)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      Z <- df |> 
        select(As:Sn)
      X <- df |>
        select(smoke:bmi)
      y <- df$y
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- tryCatch({
        kmbayes(y = y, Z = Z, X = X, 
                iter = 50000, verbose = FALSE, varsel = TRUE)
      }, error = function(e) {
        NA
      })
      end.time <- Sys.time()
      list_times[[j]] <- end.time - start.time
      list_mods[[j]] <- mod
    }
    
    # combine 1-3 r/e
    df <- df_full[df_full$race %in% c(1, 2, 3), ]
    Z <- df |> 
      select(As:Sn)
    X <- df |>
      select(smoke:bmi)
    y <- df$y
    
    # fit model and save time
    start.time <- Sys.time()
    mod <- tryCatch({
      kmbayes(y = y, Z = Z, X = X, 
              iter = 50000, verbose = FALSE, varsel = TRUE)
    }, error = function(e) {
      NA
    })
    end.time <- Sys.time()
    list_times[[6]] <- end.time - start.time
    list_mods[[6]] <- mod
    
    
    bkmr_times[[i]] <- list_times
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bkmr_sm_", names(out1_resp1_re)[i], "_", i, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bkmr_smf_", names(out1_resp1_re)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # write_rds(bkmr_times, file = "bkmr_sm_times.RDS")
  return(bkmr_times)
}

# send to hpc
ujob01 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 1:100),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre01',
  slurm_options = list(mem = '8G'))

ujob02 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 101:200),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre02',
  slurm_options = list(mem = '8G'))

ujob03 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 201:300),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre03',
  slurm_options = list(mem = '8G'))

ujob04 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 301:400),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre04',
  slurm_options = list(mem = '8G'))
```

```{r}
##########
# stratified bkmr, larger size
##########

out2_resp1_re <- read_rds("sim/sim_resp_lg_re.RDS")

run_bkmr_lg_re <- function(vector) {
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  for(i in vector) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out2_resp1_re[[i]]
    
    # for each race level, run bmkr
    list_times <- vector(mod = "list", length = 5)
    list_mods <- vector(mod = "list", length = 5)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      Z <- df |> 
        select(As:Sn)
      X <- df |>
        select(smoke:bmi)
      y <- df$y
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- kmbayes(y = y, Z = Z, X = X, 
                     iter = 50000, verbose = FALSE, varsel = TRUE)
      end.time <- Sys.time()
      list_times[[j]] <- end.time - start.time
      list_mods[[j]] <- mod
    }
    
    bkmr_times[[i]] <- list_times
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bkmr_lg_", names(out2_resp1_re)[i], "_", i, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bkmr_lgf_", names(out2_resp1_re)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # write_rds(bkmr_times, file = "bkmr_lg_times_re.RDS")
  return(bkmr_times)
}

# send to hpc
tjob01 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 1:100),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre01',
  slurm_options = list(mem = '8G'))

tjob02 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 101:200),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre02',
  slurm_options = list(mem = '8G'))

tjob03 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 201:300),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre03',
  slurm_options = list(mem = '8G'))

tjob04 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 301:400),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre04',
  slurm_options = list(mem = '8G'))
```

```{r}
###########
# stratified bsr, smaller size
###########

out1_resp1_re <- read_rds("sim/sim_resp_sm_re.RDS")

run_bsr_sm_re <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes bsr would stop prematurely...
  # so this code finds the index of the last model run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0
    starting <- min(vector)
  } else {
    final <- max(nums)
    starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out1_resp1_re[[i]]
    
    # for each race level, run bsr
    list_times <- vector(mod = "list", length = 6) 
    list_mods <- vector(mod = "list", length = 6)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      X <- df |> 
        select(As:Sn) |> 
        as.matrix.data.frame()
      C <- df |> 
        select(smoke:bmi) |> 
        as.matrix.data.frame()
      Y <- df$y
      
      # waic for choosing df
      list_times_small <- vector(mode = "list", length = 2)
      
      start.time <- Sys.time()
      mod1 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 1)
      mod2 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 2)
      mod3 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 3)
      mod4 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 4)
      end.time <- Sys.time()
      list_times_small[[1]] <- end.time - start.time
      
      ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- tryCatch({
        NLint(Y = Y, X = X, C = C, 
              nIter = 50000, nBurn = 25000, ns = ind)
      }, error = function(e) {
        NA
      })
      end.time <- Sys.time()
      list_times_small[[2]] <- end.time - start.time
      
      bsr_times[[j]] <- list_times_small
      list_mods[[j]] <- mod
    }
    
    # combine 1-3 r/e
    df <- df_full[df_full$race %in% c(1, 2, 3), ]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |> 
      select(smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # waic for choosing df
    list_times_small <- vector(mode = "list", length = 2)
    
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times_small[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    # fit model and save time
    start.time <- Sys.time()
    mod <- tryCatch({
      NLint(Y = Y, X = X, C = C, 
            nIter = 50000, nBurn = 25000, ns = ind)
    }, error = function(e) {
      NA
    })
    end.time <- Sys.time()
    list_times_small[[2]] <- end.time - start.time
    
    list_times[[6]] <- list_times_small
    list_mods[[6]] <- mod
    
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bsr_sm_", names(out1_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bsr_sm_", names(out1_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  return(bsr_times)
}

# send to hpc
vjob01 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 1:100),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre01',
  slurm_options = list(mem = '8G'))

vjob02 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 101:200),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre02',
  slurm_options = list(mem = '8G'))

vjob03 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 201:300),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre03',
  slurm_options = list(mem = '8G'))

vjob04 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 301:400),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre04',
  slurm_options = list(mem = '8G'))
```

```{r}
###########
# stratified bsr, larger size
###########

out2_resp1_re <- read_rds("sim/sim_resp_lg_re.RDS")

run_bsr_lg_re <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes bsr would stop prematurely...
  # so this code finds the index of the last model run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0
    starting <- min(vector)
  } else {
    final <- max(nums)
    starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out2_resp1_re[[i]]
    
    # for each race level, run bsr
    list_times <- vector(mod = "list", length = 6) 
    list_mods <- vector(mod = "list", length = 6)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      X <- df |> 
        select(As:Sn) |> 
        as.matrix.data.frame()
      C <- df |> 
        select(smoke:bmi) |> 
        as.matrix.data.frame()
      Y <- df$y
      
      # waic for choosing df
      list_times_small <- vector(mode = "list", length = 2)
      
      start.time <- Sys.time()
      mod1 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 1)
      mod2 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 2)
      mod3 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 3)
      mod4 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 4)
      end.time <- Sys.time()
      list_times_small[[1]] <- end.time - start.time
      
      ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- tryCatch({
        NLint(Y = Y, X = X, C = C, 
              nIter = 50000, nBurn = 25000, ns = ind)
      }, error = function(e) {
        NA
      })
      end.time <- Sys.time()
      list_times_small[[2]] <- end.time - start.time
      
      bsr_times[[j]] <- list_times_small
      list_mods[[j]] <- mod
    }
    
    # combine 1-3 r/e
    df <- df_full[df_full$race %in% c(1, 2, 3), ]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |> 
      select(smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # waic for choosing df
    list_times_small <- vector(mode = "list", length = 2)
    
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times_small[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    # fit model and save time
    start.time <- Sys.time()
    mod <- tryCatch({
      NLint(Y = Y, X = X, C = C, 
            nIter = 50000, nBurn = 25000, ns = ind)
    }, error = function(e) {
      NA
    })
    end.time <- Sys.time()
    list_times_small[[2]] <- end.time - start.time
    
    list_times[[6]] <- list_times_small
    list_mods[[6]] <- mod
    
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bsr_lg_", names(out2_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bsr_lg_", names(out2_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  # write_rds(bsr_times, file = "bsr_lgf_times.RDS")
  return(bsr_times)
}

# send to hpc
wjob01 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 1:100),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre01',
  slurm_options = list(mem = '8G'))

wjob02 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 101:200),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre02',
  slurm_options = list(mem = '8G'))

wjob03 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 201:300),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre03',
  slurm_options = list(mem = '8G'))

wjob04 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 301:400),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre04',
  slurm_options = list(mem = '8G'))

```

## Code for Chapter \@ref(results) and Appendix \@ref(suppresults)

This section includes code for extracting and presenting results in Chapter \@ref(results) and the supplemental results, Appendix \@ref(suppresults). 

### Extracting results {#extractresults}

Here, we extract results from our simulation. We use the `rslurm`, `bkmr`, and `NLinteraction` packages in this section. This code was run on the Amherst HPC RStudio server. 

First, we write custom functions to extract output from BKMR and BSR models. These functions are stored in the `extract_fxns.R` file and loaded in later in analysis. 

```{r}
# this function calculates confidence intervals for two-way interactions in BKMR
bivarinter_bkmr <- function(fit, z1, z2, qs.diff = c(0.25, 0.75), 
                            qs.fixed = c(0.25, 0.75), q.rest = 0.5) {
  #' fit = bkmr model
  #' z1 = index of chemical 1
  #' z2 = index of chemical 2
  #' qs.diff = quantiles to calculate response diff for
  #' qs.fixed = quantiles to fix other chemical at
  #' q.rest = quantile to fix rest of chemicals at
  #' 
  #' NOTE that order of z1 and z2 does not matter
  
  # extract fit
  y <- fit$y
  Z <- fit$Z
  X <- fit$X
  
  # fix all chems at q.rest
  point2 <- point1 <- apply(Z, 2, quantile, q.rest)
  # fix z2 at lower
  point2[z2] <- point1[z2] <- quantile(Z[, z2], qs.fixed[1])
  # fix z1 at lower and upper
  point2[z1] <- quantile(Z[, z1], qs.diff[2])
  point1[z1] <- quantile(Z[, z1], qs.diff[1])
  newz.q1 <- rbind(point1, point2) # has all lower quantiles of z2
  # fix all chems at q.rest
  point2 <- point1 <- apply(Z, 2, quantile, q.rest)
  # fix z2 at higher
  point2[z2] <- point1[z2] <- quantile(Z[, z2], qs.fixed[2])
  # fix z1 at lower and upper
  point2[z1] <- quantile(Z[, z1], qs.diff[2])
  point1[z1] <- quantile(Z[, z1], qs.diff[1])
  newz.q2 <- rbind(point1, point2) # has all upper quantiles of z2
  
  # prepare
  cc <- c(-1 * c(-1, 1), c(-1, 1))
  newz <- rbind(newz.q1, newz.q2)
  
  # default to using approximate calculation
  preds <- ComputePostmeanHnew(fit = fit, y = y, Z = Z, X = X, Znew = newz)
  
  # extract intervals
  int <- drop(cc %*% preds$postmean)
  int.se <- drop(sqrt(cc %*% preds$postvar %*% cc))
  ints <- c(est = int, sd = int.se)
  
  return(data.frame(z1 = colnames(Z)[z1], z2 = colnames(Z)[z2], 
                    est = ints["est"], sd = ints["sd"], row.names = NULL))
}

# this function calculates confidence intervals for three-way interactions in BKMR
trivarinter_bkmr <- function(fit, z1, z2, z3, qs.diff = c(0.25, 0.75), 
                             qs.fixed = c(0.25, 0.75), q.rest = 0.5) {
  #' fit = bkmr model
  #' z1 = index of chemical 1
  #' z2 = index of chemical 2
  #' z3 = index of chemical 3
  #' qs.diff = quantiles to calculate response diff for
  #' qs.fixed = quantiles to fix other chemical at
  #' q.rest = quantile to fix rest of chemicals at
  #' 
  #' NOTE that order of z1, z2, z3 does not matter
  
  # extract fit
  y <- fit$y
  Z <- fit$Z
  X <- fit$X
  
  df <- purrr::map_df(1:3, \(x) {
    if(x == 1) {
      c1 <- z1; c2 <- z2; c3 <- z3
    } else if (x == 2) {
      c1 <- z2; c2 <- z3; c3 <- z1
    } else {
      c1 <- z3; c2 <- z1; c3 <- z2
    }
    
    # fix all chems at q.rest
    point2 <- point1 <- apply(Z, 2, quantile, q.rest)
    # fix c2 at lower
    point2[c2] <- point1[c2] <- quantile(Z[, c2], qs.fixed[1])
    # fix c3 at lower
    point2[c3] <- point1[c3] <- quantile(Z[, c3], qs.fixed[1])
    # fix c1 at lower and upper
    point2[c1] <- quantile(Z[, c1], qs.diff[2])
    point1[c1] <- quantile(Z[, c1], qs.diff[1])
    newz.q1 <- rbind(point1, point2) # has all lower quantiles of c2, c3
    # fix all chems at q.rest
    point2 <- point1 <- apply(Z, 2, quantile, q.rest)
    # fix c2 at higher
    point2[c2] <- point1[c2] <- quantile(Z[, c2], qs.fixed[2])
    # fix c3 at higher
    point2[c3] <- point1[c3] <- quantile(Z[, c3], qs.fixed[2])
    # fix c1 at lower and upper
    point2[c1] <- quantile(Z[, c1], qs.diff[2])
    point1[c1] <- quantile(Z[, c1], qs.diff[1])
    newz.q2 <- rbind(point1, point2) # has all upper quantiles of c2, c3
    
    # prepare
    cc <- c(-1 * c(-1, 1), c(-1, 1))
    newz <- rbind(newz.q1, newz.q2)
    
    # default to using approximate calculation
    preds <- ComputePostmeanHnew(fit = fit, y = y, Z = Z, X = X, Znew = newz)
    
    # extract intervals
    int <- drop(cc %*% preds$postmean)
    int.se <- drop(sqrt(cc %*% preds$postvar %*% cc))
    ints <- c(est = int, sd = int.se)
    
    return(data.frame(variable = colnames(Z)[c1], fixedat1 = colnames(Z)[c2], 
                      fixedat2 = colnames(Z)[c3],
                      est = ints["est"], sd = ints["sd"], row.names = NULL))
  })
  
 return(df)
}

# this function generates estimated exposure-response relationships 
# to assess three-way interactions in BKMR
trivarsurf_bkmr <- function(fit, z1, z2, z3, qs.diff = c(0.1, 0.5, 0.9), 
                            q.fixed = 0.5, ngrid = 50) {
  #' fit = bkmr model
  #' z1 = index of chemical 1
  #' z2 = index of chemical 2
  #' z3 = index of chemical 3
  #' qs.diff = quantiles to calculate response diff for
  #' q.fixed = quantiles to fix rest of chemicals at
  #' 
  #' NOTE that order of z1, z2, z3 does not matter

  # call from fit
  y <- fit$y
  Z <- fit$Z
  X <- fit$X
  z.names <- colnames(Z)
  
  df <- purrr::map_df(1:3, \(x) {
    if(x == 1) {
      c1 <- z1; c2 <- z2; c3 <- z3
    } else if (x == 2) {
      c1 <- z2; c2 <- z3; c3 <- z1
    } else {
      c1 <- z3; c2 <- z1; c3 <- z2
    }
    
    # create new ordering
    ord <- c(c1, c2, c3, setdiff(1:ncol(Z), c(c1, c2, c3)))
    
    # create grid of z-values to evaluate at
    z1.grid <- seq(min(Z[, ord[1]]), max(Z[, ord[1]]), length = ngrid)
    z2.grid <- quantile(Z[, ord[2]], probs = qs.diff)
    z3.grid <- quantile(Z[, ord[3]], probs = qs.diff)
    z.all <- c(list(z1.grid), list(z2.grid), list(c(-99)))
    if (ncol(Z) > 3) {
      z.others <- lapply(4:ncol(Z), function(x) quantile(Z[, ord[x]], q.fixed))
      z.all <- c(z.all, z.others)
    }
    newz.grid <- expand.grid(z.all)
    newz.grid[, 3] <- rep(z3.grid, each = ngrid)
    z1save <- newz.grid[, 1]
    colnames(newz.grid) <- colnames(Z)[ord]
    newz.grid <- newz.grid[, colnames(Z)]
    
    # evaluate prediction, assume approx fit
    preds <- ComputePostmeanHnew(fit = fit, y = y, Z = Z, X = X, Znew = newz.grid)
    preds.mean <- preds$postmean
    preds.se <- sqrt(diag(preds$postvar))
    
    # return
    return(data.frame(z1_val = z1save, 
                      z23_q = rep(qs.diff, each = ngrid), 
                      est = preds.mean, 
                      se = preds.se, 
                      z1_name = rep(colnames(Z)[c1], length(z1save)), 
                      z2_name = rep(colnames(Z)[c2], length(z1save)), 
                      z3_name = rep(colnames(Z)[c3], length(z1save))))
  })
  
  return(df)
}

# this function estimates exposure-response relationship for one chemical in BSR
univarsurf_bsr <- function(NLmod, X, C, j1, gridLength = 50, 
                           quantile_rest = 0.5) {
  #' NLmod = bsr model
  #' X = matrix or dataframe of chemical values used to fit model
  #' C = matrix or dataframe of covariate values used to fit model
  #' gridLength = number of points to estimate response at
  #' j1 = index of chemical
  #' quantile_rest = quantile to fix other chemicals at
  
  # define parameters
  n  <-  dim(X)[1]
  ns <- NLmod$ns
  k <- NLmod$k
  p <- dim(X)[2]
  Xstar <- array(NA, dim = c(n, p, ns + 1))
  Xstar[, , 1] <- 1
  for (j in 1:p) {
    Xstar[, j, 2:(ns + 1)] <- scale(splines::ns(X[, j], df = ns))
  }
  
  # define posteriors
  zetaPost <- NLmod$posterior$zeta
  betaList <- NLmod$posterior$beta
  betaCPost <- NLmod$posterior$betaC
  totalScans <- dim(NLmod$posterior$betaC)[2]
  nChains <- dim(NLmod$posterior$betaC)[1]
  
  # create design of covariates
  pc <- dim(C)[2]
  NewDesignC <- matrix(NA, gridLength, pc + 1)
  NewDesignC[, 1] <- 1
  for (jc in 1:pc) {
    NewDesignC[, jc + 1] <- mean(C[, jc])
  }
  
  # create design of chemicals
  n <- dim(X)[1]
  NewDesignMat <- matrix(NA, gridLength, p)
  for (j in 1:p) {
    NewDesignMat[, j] <- quantile(X[, j], quantile_rest)
  }
  NewDesignMat[, j1] <- seq(quantile(X[, j1], 0.025),
                            quantile(X[, j1], 0.975), length = gridLength)
  NewDesign <- array(NA, dim = c(gridLength, p, ns + 1))
  NewDesign[, , 1] <- 1
  for (j in 1:p) {
    temp_ns_object <- splines::ns(X[, j], df = ns)
    temp_sds <- apply(temp_ns_object, 2, sd)
    temp_means <- apply(temp_ns_object, 2, mean)
    NewDesign[, j, 2:(ns + 1)] <- t((t(
      predict(temp_ns_object,
              NewDesignMat[, j])
    ) - temp_means) / temp_sds)
  }
  
  # generate predictions
  predictions <- NLinteraction:::PredictionsMixture(
    XstarOld = Xstar,
    XstarNew = NewDesign,
    designC = NewDesignC,
    totalScans = totalScans,
    nChains = nChains,
    zetaPost = zetaPost,
    betaList = betaList,
    betaCPost = betaCPost,
    k = k,
    ns = ns
  )
  
  return(data.frame(
    j1val = NewDesignMat[, j1], 
    est = apply(predictions$PredictedPost, 3, mean), 
    lower = apply(predictions$PredictedPost, 3, quantile, 0.025), 
    upper = apply(predictions$PredictedPost, 3, quantile, 0.975)))
}

# this function generates estimated exposure-response relationships 
# to assess two-way interactions in BSR
bivarsurf_bsr <- function(NLmod, X, C, j1, j2, gridLength = 50, 
                          quantile_j2 = c(0.1, 0.5, 0.9), quantile_rest = 0.5) {
  #' NLmod = bsr model
  #' X = matrix or dataframe of chemical values used to fit model
  #' C = matrix or dataframe of covariate values used to fit model
  #' gridLength = number of points to estimate response at
  #' j1 = index of first chemical
  #' j2 = index of second chemical
  #' quantile_j2 = vector of quantiles to fix second chemical at
  #' quantile_rest = quantile to fix other chemicals at
  #' 
  #' NOTE order of j1 and j2 does not matter
  
  # define parameters
  n  <-  dim(X)[1]
  ns <- NLmod$ns
  k <- NLmod$k
  p <- dim(X)[2]
  Xstar <- array(NA, dim = c(n, p, ns + 1))
  Xstar[, , 1] <- 1
  for (j in 1:p) {
    Xstar[, j, 2:(ns + 1)] <- scale(splines::ns(X[, j], df = ns))
  }
  
  # define posteriors
  zetaPost <- NLmod$posterior$zeta
  betaList <- NLmod$posterior$beta
  betaCPost <- NLmod$posterior$betaC
  totalScans <- dim(NLmod$posterior$betaC)[2]
  nChains <- dim(NLmod$posterior$betaC)[1]
  
  # create design of covariates
  pc <- dim(C)[2]
  NewDesignC <- matrix(NA, gridLength, pc + 1)
  NewDesignC[, 1] <- 1
  for (jc in 1:pc) {
    NewDesignC[, jc + 1] <- mean(C[, jc])
  }
  
  # for each quantile of j2
  df <- purrr::map_df(quantile_j2, \(quantile_j2) {
    # create design of chemicals
    n <- dim(X)[1]
    NewDesignMat <- matrix(NA, gridLength, p)
    for (j in 1:p) {
      NewDesignMat[, j] <- quantile(X[, j], quantile_rest)
    }
    NewDesignMat[, j1] <- seq(quantile(X[, j1], 0.025), 
                             quantile(X[, j1], 0.975), length = gridLength)
    NewDesignMat[, j2] <- quantile(X[, j2], quantile_j2)
    NewDesign <- array(NA, dim = c(gridLength, p, ns + 1))
    NewDesign[, , 1] <- 1
    for (j in 1:p) {
      temp_ns_object <- splines::ns(X[, j], df = ns)
      temp_sds <- apply(temp_ns_object, 2, sd)
      temp_means <- apply(temp_ns_object, 2, mean)
      NewDesign[, j, 2:(ns + 1)] <- t((t(predict(temp_ns_object, 
                                                NewDesignMat[, j])) - temp_means)/temp_sds)
    }
    
    # generate predictions
    predictions <- NLinteraction:::PredictionsMixture(
      XstarOld = Xstar, XstarNew = NewDesign, 
      designC = NewDesignC, totalScans = totalScans, nChains = nChains, 
      zetaPost = zetaPost, betaList = betaList, betaCPost = betaCPost, 
      k = k, ns = ns)
    
    # get surface
    return(data.frame(
      j1val = NewDesignMat[, j1], 
      j2quant = rep(quantile_j2, gridLength), 
      est = apply(predictions$PredictedPost, 3, mean), 
      lower = apply(predictions$PredictedPost, 3, quantile, 0.025), 
      upper = apply(predictions$PredictedPost, 3, quantile, 0.975)
    ))
  })
  return(df)
}

# this function generates estimated exposure-response relationships 
# to assess three-way interactions in BSR
trivarsurf_bsr <- function(NLmod, X, C, j1, j2, j3, gridLength = 50, 
                           quantile_j23 = c(0.1, 0.5, 0.9), quantile_rest = 0.5) {
  #' NLmod = bsr model
  #' X = matrix or dataframe of chemical values used to fit model
  #' C = matrix or dataframe of covariate values used to fit model
  #' gridLength = number of points to estimate response at
  #' j1 = index of first chemical, chemical used as primary predictor
  #' j2 = index of second chemical
  #' j3 = index of third chemical
  #' quantile_j23 = vector of quantiles to fix second and third chemicals at
  #' quantile_rest = quantile to fix other chemicals at
  #' 
  #' NOTE order of j1, j2, j3 matters

  # define parameters
  n  <-  dim(X)[1]
  ns <- NLmod$ns
  k <- NLmod$k
  p <- dim(X)[2]
  Xstar <- array(NA, dim = c(n, p, ns + 1))
  Xstar[, , 1] <- 1
  for (j in 1:p) {
    Xstar[, j, 2:(ns + 1)] <- scale(splines::ns(X[, j], df = ns))
  }
  
  # define posteriors
  zetaPost <- NLmod$posterior$zeta
  betaList <- NLmod$posterior$beta
  betaCPost <- NLmod$posterior$betaC
  totalScans <- dim(NLmod$posterior$betaC)[2]
  nChains <- dim(NLmod$posterior$betaC)[1]
  
  # create design of covariates
  pc <- dim(C)[2]
  NewDesignC <- matrix(NA, gridLength, pc + 1)
  NewDesignC[, 1] <- 1
  for (jc in 1:pc) {
    NewDesignC[, jc + 1] <- mean(C[, jc])
  }
  
  # for each quantile of j2, j3
  df <- purrr::map_df(quantile_j23, \(quantile_j23) {
    # create design of chemicals
    n <- dim(X)[1]
    NewDesignMat <- matrix(NA, gridLength, p)
    for (j in 1:p) {
      NewDesignMat[, j] <- quantile(X[, j], quantile_rest)
    }
    NewDesignMat[, j1] <- seq(quantile(X[, j1], 0.025), 
                              quantile(X[, j1], 0.975), length = gridLength)
    NewDesignMat[, j2] <- quantile(X[, j2], quantile_j23)
    NewDesignMat[, j3] <- quantile(X[, j3], quantile_j23)
    NewDesign <- array(NA, dim = c(gridLength, p, ns + 1))
    NewDesign[, , 1] <- 1
    for (j in 1:p) {
      temp_ns_object <- splines::ns(X[, j], df = ns)
      temp_sds <- apply(temp_ns_object, 2, sd)
      temp_means <- apply(temp_ns_object, 2, mean)
      NewDesign[, j, 2:(ns + 1)] <- t((t(predict(temp_ns_object, 
                                                 NewDesignMat[, j])) - temp_means)/temp_sds)
    }
    
    # generate predictions
    predictions <- NLinteraction:::PredictionsMixture(
      XstarOld = Xstar, XstarNew = NewDesign, 
      designC = NewDesignC, totalScans = totalScans, nChains = nChains, 
      zetaPost = zetaPost, betaList = betaList, betaCPost = betaCPost, 
      k = k, ns = ns)
    
    # get surface
    return(data.frame(
      j1val = NewDesignMat[, j1], 
      j23quant = rep(quantile_j23, gridLength), 
      est = apply(predictions$PredictedPost, 3, mean), 
      lower = apply(predictions$PredictedPost, 3, quantile, 0.025), 
      upper = apply(predictions$PredictedPost, 3, quantile, 0.975)
    ))
  })
  return(df)
}
```

Now, we extract p-values from the multiple linear regression models. 

```{r}
# naive small, chemxchem models
mlr_sm <- read_rds("sim/mlr_mods_sm.RDS")

mlrsm_pval <- 1:1700 |> 
  map_df(\(x) {
    mod <- mlr_sm[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(mlrsm_pval, "sim/_mlr/pvalsm.csv")

# naive large, chemxchem models
mlr_lg <- read_rds("sim/mlr_mods_lg.RDS")

mlrlg_pval <- 1:1700 |> 
  map_df(\(x) {
    mod <- mlr_lg[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(mlrlg_pval, "sim/_mlr/pvallg.csv")

# oracle small, chemxchem models
orac_sm <- read_rds("sim/oracle_mods_sm.RDS")

oracsm_pval <- 1:1700 |> 
  map_df(\(x) {
    mod <- orac_sm[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(oracsm_pval, "sim/_oracle/pvalsm.csv")

# oracle large, chemxchem models
orac_lg <- read_rds("sim/oracle_mods_lg.RDS")

oraclg_pval <- 1:1700 |> 
  map_df(\(x) {
    mod <- orac_lg[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(oraclg_pval, "sim/_oracle/pvallg.csv")
```

Next, we extract output from BKMR models run on smaller and larger size simulated datasets, including the base case and models with interactions between chemicals. 

```{r}
# load packages
library(tidyverse)
library(bkmr)

######
# extract bkmr smalls!
######

# get file paths of models
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ksm <- list_files[grepl("_rslurm_bkmr_sm", list_files)]

ksm_subf <- list.dirs(list_ksm, full.names = TRUE, recursive = TRUE)
ksm_mod <- ksm_subf[grepl("mods", ksm_subf)]

ksm_labels <- gsub("\\D", "", ksm_mod)
ksm_labels <- ifelse(ksm_labels == "", 1, as.numeric(ksm_labels))

# get paths
ksm_paths <- ksm_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ksm_labels)

# extract PIP's
ksm_pips <- names(ksm_paths) |> 
  purrr::map_df(\(x) {
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- data.frame(
          ExtractPIPs(bkmr)
        ) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_pips, "sim/bkmr_sm/pips.csv")

# extract univariate relationships
ksm_univ <- names(ksm_paths) |> 
  purrr::map_df(\(x) {
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- data.frame(
          PredictorResponseUnivar(bkmr)
        ) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_univ, "sim/bkmr_sm/univ_expresp.csv")

# extract bivariate relationships
ksm_biv <- names(ksm_paths)[2:13] |> # only for 2-way interaction
  purrr::map_df(\(x) {
    indices <- case_when(
      x %in% 2:5 ~ c(4, 5), # Hg and Ni
      x %in% 6:9 ~ c(1, 2), # Cd and As
      x %in% 10:13 ~ c(3, 5) # Co and Ni
    )
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        bivar <- PredictorResponseBivar(bkmr, 
                               z.pairs = rbind(indices), verbose = FALSE)
        result <- data.frame(
          PredictorResponseBivarLevels(
            pred.resp.df = bivar, 
            Z = bkmr$Z, qs = c(0.1, 0.5, 0.9))
          
        ) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
ksm_biv_nona <- na.omit(ksm_biv)
write_csv(ksm_biv_nona, "sim/bkmr_sm/biv_expresp.csv")

# load in fxn
source("extract_fxns.R")

# extract trivariate relationships
ksm_triv <- names(ksm_paths)[14:17] |> # only for 3-way
  purrr::map_df(\(x) {
    message("starting ", x)
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- trivarsurf_bkmr(bkmr, 4, 5, 6, 
                                  qs.diff = c(0.1, 0.5, 0.9), 
                                  q.fixed = 0.5, ngrid = 50) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_triv, "sim/bkmr_sm/triv_expresp.csv")

# extract one vs. rest bivariate interactions
ksm_ints <- names(ksm_paths)[2:17] |> 
  purrr::map_df(\(x) {
    print(paste0("starting ", x))
    indices <- case_when(
      x %in% 2:5 ~ list(c(4, 5)), # Hg and Ni
      x %in% 6:9 ~ list(c(1, 2)), # Cd and As
      x %in% 10:13 ~ list(c(3, 5)), # Co and Ni
      x %in% 14:17 ~ list(c(4, 5, 6)) # Hg, Ni, Tl
    )
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        ints <- SingVarIntSummaries(bkmr, 
                                    which.z = indices[[1]], 
                                    qs.diff = c(0.25, 0.75), 
                                    qs.fixed = c(0.25, 0.75),
                                    method = "approx")
        result <- data.frame(ints) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_ints, "sim/bkmr_sm/ints.csv")

# load in fxn
source("extract_fxns.R")

# extract one vs. other bivariate interactions
ksm_intb <- names(ksm_paths)[2:13] |> # only for two-way
  purrr::map_df(\(x) {
    print(paste0("starting ", x))
    indices <- case_when(
      x %in% 2:5 ~ list(c(4, 5)), # Hg and Ni
      x %in% 6:9 ~ list(c(1, 2)), # Cd and As
      x %in% 10:13 ~ list(c(3, 5)) # Co and Ni
    )
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        ints <- bivarinter_bkmr(bkmr, 
                                z1 = indices[[1]][1], 
                                z2 = indices[[1]][2], 
                                qs.diff = c(0.25, 0.75), 
                                qs.fixed = c(0.25, 0.75),
                                q.rest = 0.5)
        result <- data.frame(ints) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_intb, "sim/bkmr_sm/int_bivar.csv")

# FDR for Hg-Ni
indices <- t(combn(1:10, 2))
ksm_intb_hgni <- names(ksm_paths)[2:5] |> # only for Hg-Ni
  purrr::map_df(\(x) {
    message("starting ", x)
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- 1:45 |> 
          purrr::map_df(\(z) {
            ints <- bivarinter_bkmr(bkmr, 
                                    z1 = indices[z, ][1], 
                                    z2 = indices[z, ][2], 
                                    qs.diff = c(0.25, 0.75), 
                                    qs.fixed = c(0.25, 0.75),
                                    q.rest = 0.5)
            data.frame(ints)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_intb_hgni, "sim/bkmr_sm/int_bivar_fullhgni.csv")

# FDR for rest
indices <- t(combn(1:10, 2))
ksm_intb_rest <- names(ksm_paths)[6:13] |> # for rest
  purrr::map_df(\(x) {
    message("starting ", x)
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- 1:45 |> 
          purrr::map_df(\(z) {
            ints <- bivarinter_bkmr(bkmr, 
                                    z1 = indices[z, ][1], 
                                    z2 = indices[z, ][2], 
                                    qs.diff = c(0.25, 0.75), 
                                    qs.fixed = c(0.25, 0.75),
                                    q.rest = 0.5)
            data.frame(ints)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_intb_rest, "sim/bkmr_sm/int_bivar_fullrest.csv")

# extract one vs. 2 others trivariate interactions
ksm_intt <- names(ksm_paths)[14:17] |> # only for three-way
  purrr::map_df(\(x) {
    print(paste0("starting ", x))
    ksm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        ints <- trivarinter_bkmr(bkmr, 
                                 z1 = 4, z2 = 5, z3 = 6,
                                 qs.diff = c(0.25, 0.75), 
                                 qs.fixed = c(0.25, 0.75),
                                 q.rest = 0.5)
        result <- data.frame(ints) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ksm_intt, "sim/bkmr_sm/int_trivar.csv")


######
# extract bkmr larges!
######
  
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_klg <- list_files[grepl("_rslurm_bkmr_lg", list_files)]

klg_subf <- list.dirs(list_klg, full.names = TRUE, recursive = TRUE)
klg_mod <- klg_subf[grepl("mods", klg_subf)]

klg_labels <- gsub("\\D", "", klg_mod)
klg_labels <- ifelse(klg_labels == "", 1, as.numeric(klg_labels))

# get paths
klg_paths <- klg_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = klg_labels)

# extract PIP's
klg_pips <- names(klg_paths) |> 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- data.frame(
          ExtractPIPs(bkmr)
        ) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_pips, "sim/bkmr_lg/pips.csv")

# extract univariate relationships
klg_univ <- names(klg_paths) |> 
  purrr::map_df(\(x) {
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- data.frame(
          PredictorResponseUnivar(bkmr)
        ) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_univ, "sim/bkmr_lg/univ_expresp.csv")

# extract bivariate relationships
klg_biv <- names(klg_paths)[2:13] |> # only for 2-way interaction
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    indices <- case_when(
      x %in% 2:5 ~ c(4, 5), # Hg and Ni
      x %in% 6:9 ~ c(1, 2), # Cd and As
      x %in% 10:13 ~ c(3, 5) # Co and Ni
    )
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        bivar <- PredictorResponseBivar(bkmr, 
                                        z.pairs = rbind(indices), verbose = FALSE)
        result <- data.frame(
          PredictorResponseBivarLevels(
            pred.resp.df = bivar, 
            Z = bkmr$Z, qs = c(0.1, 0.5, 0.9))
          
        ) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
# write_csv(klg_biv, "sim/bkmr_lg/biv_expresp.csv")
# write_rds(klg_biv, "sim/bkmr_lg/biv_expresp.rds")
klg_biv_nona <- na.omit(klg_biv)
write_csv(klg_biv_nona, "sim/bkmr_lg/biv_expresp.csv")

# load in fxn
source("extract_fxns.R")

# extract trivariate relationships
klg_triv <- names(klg_paths)[14:17] |> # only for 3-way
  purrr::map_df(\(x) {
    message("starting ", x)
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- trivarsurf_bkmr(bkmr, 4, 5, 6, 
                                  qs.diff = c(0.1, 0.5, 0.9), 
                                  q.fixed = 0.5, ngrid = 50) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_triv, "sim/bkmr_lg/triv_expresp.csv")

# extract one vs. rest bivariate interactions
klg_ints <- names(klg_paths)[2:17] |> 
  purrr::map_df(\(x) {
    print(paste0("starting ", x))
    indices <- case_when(
      x %in% 2:5 ~ list(c(4, 5)), # Hg and Ni
      x %in% 6:9 ~ list(c(1, 2)), # Cd and As
      x %in% 10:13 ~ list(c(3, 5)), # Co and Ni
      x %in% 14:17 ~ list(c(4, 5, 6)) # Hg, Ni, Tl
    )
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        ints <- SingVarIntSummaries(bkmr, 
                                    which.z = indices[[1]], 
                                    qs.diff = c(0.25, 0.75), 
                                    qs.fixed = c(0.25, 0.75),
                                    method = "approx")
        result <- data.frame(ints) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_ints, "sim/bkmr_lg/ints.csv")

# load in fxn
source("extract_fxns.R")

# extract one vs. other bivariate interactions
klg_intb <- names(klg_paths)[2:13] |> # only for two-way
  purrr::map_df(\(x) {
    print(paste0("starting ", x))
    indices <- case_when(
      x %in% 2:5 ~ list(c(4, 5)), # Hg and Ni
      x %in% 6:9 ~ list(c(1, 2)), # Cd and As
      x %in% 10:13 ~ list(c(3, 5)) # Co and Ni
    )
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        ints <- bivarinter_bkmr(bkmr, 
                                z1 = indices[[1]][1], 
                                z2 = indices[[1]][2], 
                                qs.diff = c(0.25, 0.75), 
                                qs.fixed = c(0.25, 0.75),
                                q.rest = 0.5)
        result <- data.frame(ints) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_intb, "sim/bkmr_lg/int_bivar.csv")

# FDR for Hg-Ni
indices <- t(combn(1:10, 2))
klg_intb_hgni <- names(klg_paths)[2:5] |> # only for Hg-Ni
  purrr::map_df(\(x) {
    message("starting ", x)
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- 1:45 |> 
          purrr::map_df(\(z) {
            ints <- bivarinter_bkmr(bkmr, 
                                    z1 = indices[z, ][1], 
                                    z2 = indices[z, ][2], 
                                    qs.diff = c(0.25, 0.75), 
                                    qs.fixed = c(0.25, 0.75),
                                    q.rest = 0.5)
            data.frame(ints)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_intb_hgni, "sim/bkmr_lg/int_bivar_fullhgni.csv")

# FDR for rest
indices <- t(combn(1:10, 2))
klg_intb_rest <- names(klg_paths)[6:13] |> # for Cd-As and Ni-Co
  purrr::map_df(\(x) {
    message("starting ", x)
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        result <- 1:45 |> 
          purrr::map_df(\(z) {
            ints <- bivarinter_bkmr(bkmr, 
                                    z1 = indices[z, ][1], 
                                    z2 = indices[z, ][2], 
                                    qs.diff = c(0.25, 0.75), 
                                    qs.fixed = c(0.25, 0.75),
                                    q.rest = 0.5)
            data.frame(ints)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_intb_rest, "sim/bkmr_lg/int_bivar_fullrest.csv")

# extract one vs. 2 others trivariate interactions
klg_intt <- names(klg_paths)[14:17] |> # only for three-way
  purrr::map_df(\(x) {
    print(paste0("starting ", x))
    klg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bkmr <- read_rds(y)
        ints <- trivarinter_bkmr(bkmr, 
                                 z1 = 4, z2 = 5, z3 = 6,
                                 qs.diff = c(0.25, 0.75), 
                                 qs.fixed = c(0.25, 0.75),
                                 q.rest = 0.5)
        result <- data.frame(ints) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
        rm(bkmr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(klg_intt, "sim/bkmr_lg/int_trivar.csv")
```

Next, we extract output from BSR models run on smaller and larger size simulated datasets, including the base case and models with interactions between chemicals. 

```{r}
# load packages
library(NLinteraction)
library(tidyverse)

# create indices of chemical names
cnames <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")

######
# extract bsr smalls!
######

# extracting file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ssm <- list_files[grepl("_rslurm_bsr_sm", list_files)]

ssm_subf <- list.dirs(list_ssm, full.names = TRUE, recursive = TRUE)
ssm_mod <- ssm_subf[grepl("mods", ssm_subf)]

ssm_labels <- gsub("\\D", "", ssm_mod)
ssm_labels <- ifelse(ssm_labels == "", 1, as.numeric(ssm_labels))

# get paths
ssm_paths <- ssm_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ssm_labels)

# extract PIPs
ssm_pips <- names(ssm_paths) |> 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    ssm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- data.frame(variable = cnames, PIP = bsr$MainPIP) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns)
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ssm_pips, "sim/bsr_sm/pips.csv")

# extract bivariate pip's
ssm_pip_biv <- names(ssm_paths) |> 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    ssm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- reshape2::melt(bsr$InteractionPIP, 
                                 na.rm = TRUE, 
                                 value.name = "PIP") |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns)
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ssm_pip_biv, "sim/bsr_sm/pip_biv.csv")

# extract trivariate pip's
ssm_pip_triv <- names(ssm_paths)[14:17] |> # trivariate only
  purrr::map_df(\(x) {
    print(paste0("starting at ", x)) 
    ssm_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y) 
        result <- data.frame(
          PIP = InteractionProb(NLmod = bsr, Xsub = c(4, 5, 6)), 
          trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
          df = bsr$ns
        )
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(ssm_pip_triv, "sim/bsr_sm/pip_triv.csv")

# read back in data
out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

# load in functions for extracting results
source("extract_fxns.R")

# extract bivariate relationships
ssm_biv <- names(ssm_paths)[2:13] |> # bivariate only 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    indices <- case_when(
      x %in% 2:5 ~ c(4, 5), # Hg and Ni
      x %in% 6:9 ~ c(1, 2), # Cd and As
      x %in% 10:13 ~ c(3, 5) # Co and Ni
    )
    ssm_paths[[x]] |> 
      purrr::map_df(\(y) {
        trial <- as.numeric(sub(".+_(.+)d.+", "\\1", y))
        if(trial %% 5 == 0) print(paste0("index ", y))
        df <- out1_resp1[[trial]]
        X <- df |> 
          select(As:Sn) |> 
          as.matrix.data.frame()
        C <- df |>
          bind_cols(
            data.frame(model.matrix(~ race-1, data = 
                                      mutate(df, race = as.factor(race))))
          ) |> 
          select(race2:race5, smoke:bmi) |> 
          as.matrix.data.frame()
        Y <- df$y
        
        bsr <- read_rds(y)
        
        result1 <- bivarsurf_bsr(bsr, X = X, C = C, j1 = indices[1], j2 = indices[2], 
                                gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[indices[1]], 
                 j2 = cnames[indices[2]])
        result2 <- bivarsurf_bsr(bsr, X = X, C = C, j1 = indices[2], j2 = indices[1], 
                                 gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                 quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[indices[2]], 
                 j2 = cnames[indices[1]])
        
        rm(bsr)
        return(bind_rows(result1, result2))
      }) |> 
      mutate(case = x)
  })
write_csv(ssm_biv, "sim/bsr_sm/biv_expresp.csv")

# extract trivariate relationships
ssm_triv <- names(ssm_paths)[14:17] |> # trivariate only 
  purrr::map_df(\(x) {
    message("starting ", x)
    ssm_paths[[x]] |> 
      purrr::map_df(\(y) {
        trial <- as.numeric(sub(".+_(.+)d.+", "\\1", y))
        if(trial %% 5 == 0) message("   index ", trial)
        df <- out1_resp1[[trial]]
        X <- df |> 
          select(As:Sn) |> 
          as.matrix.data.frame()
        C <- df |>
          bind_cols(
            data.frame(model.matrix(~ race-1, data = 
                                      mutate(df, race = as.factor(race))))
          ) |> 
          select(race2:race5, smoke:bmi) |> 
          as.matrix.data.frame()
        Y <- df$y
        
        bsr <- read_rds(y)
        
        result1 <- trivarsurf_bsr(bsr, X = X, C = C, j1 = 4, j2 = 5, j3 = 6,
                                  gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                  quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[4], 
                 j2 = cnames[5], 
                 j3 = cnames[6])
        result2 <- trivarsurf_bsr(bsr, X = X, C = C, j1 = 5, j2 = 6, j3 = 4,
                                  gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                  quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[5], 
                 j2 = cnames[6], 
                 j3 = cnames[4])
        result3 <- trivarsurf_bsr(bsr, X = X, C = C, j1 = 6, j2 = 4, j3 = 5,
                                  gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                  quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[6], 
                 j2 = cnames[4], 
                 j3 = cnames[5])
        
        rm(bsr)
        return(bind_rows(result1, result2, result3))
      }) |> 
      mutate(case = x)
  })
write_csv(ssm_triv, "sim/bsr_sm/triv_expresp.csv")

######
# extract bsr larges!
######

# extracting file names

list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_slg <- list_files[grepl("_rslurm_bsr_lg", list_files)]

slg_subf <- list.dirs(list_slg, full.names = TRUE, recursive = TRUE)
slg_mod <- slg_subf[grepl("mods", slg_subf)]

slg_labels <- gsub("\\D", "", slg_mod)
slg_labels <- ifelse(slg_labels == "", 1, as.numeric(slg_labels))

# get paths
slg_paths <- slg_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = slg_labels)

# extract PIPs
slg_pips <- names(slg_paths) |> 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    slg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- data.frame(variable = cnames, PIP = bsr$MainPIP) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns)
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(slg_pips, "sim/bsr_lg/pips.csv")

# extract bivariate pip's
slg_pip_biv <- names(slg_paths) |> 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    slg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- reshape2::melt(bsr$InteractionPIP, 
                                 na.rm = TRUE, 
                                 value.name = "PIP") |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns)
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(slg_pip_biv, "sim/bsr_lg/pip_biv.csv")

# extract trivariate pip's
slg_pip_triv <- names(slg_paths)[14:17] |> # trivariate only
  purrr::map_df(\(x) {
    print(paste0("starting at ", x)) 
    slg_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y) 
        result <- data.frame(
          PIP = InteractionProb(NLmod = bsr, Xsub = c(4, 5, 6)), 
          trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
          df = bsr$ns
        )
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })
write_csv(slg_pip_triv, "sim/bsr_lg/pip_triv.csv")

# read back in data
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")
source("extract_fxns.R")

# extract bivariate relationships
slg_biv <- names(slg_paths)[2:13] |> # bivariate only 
  purrr::map_df(\(x) {
    print(paste0("starting at ", x))
    indices <- case_when(
      x %in% 2:5 ~ c(4, 5), # Hg and Ni
      x %in% 6:9 ~ c(1, 2), # Cd and As
      x %in% 10:13 ~ c(3, 5) # Co and Ni
    )
    slg_paths[[x]] |> 
      purrr::map_df(\(y) {
        trial <- as.numeric(sub(".+_(.+)d.+", "\\1", y))
        if(trial %% 5 == 0) print(paste0("index ", y))
        df <- out2_resp1[[trial]]
        X <- df |> 
          select(As:Sn) |> 
          as.matrix.data.frame()
        C <- df |>
          bind_cols(
            data.frame(model.matrix(~ race-1, data = 
                                      mutate(df, race = as.factor(race))))
          ) |> 
          select(race2:race5, smoke:bmi) |> 
          as.matrix.data.frame()
        Y <- df$y
        
        bsr <- read_rds(y)
        
        result1 <- bivarsurf_bsr(bsr, X = X, C = C, j1 = indices[1], j2 = indices[2], 
                                 gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                 quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[indices[1]], 
                 j2 = cnames[indices[2]])
        result2 <- bivarsurf_bsr(bsr, X = X, C = C, j1 = indices[2], j2 = indices[1], 
                                 gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                 quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[indices[2]], 
                 j2 = cnames[indices[1]])
        
        rm(bsr)
        return(bind_rows(result1, result2))
      }) |> 
      mutate(case = x)
  })
write_csv(slg_biv, "sim/bsr_lg/biv_expresp.csv")

# extract trivariate relationships
slg_triv <- names(slg_paths)[14:17] |> # trivariate only 
  purrr::map_df(\(x) {
    message("starting ", x)
    slg_paths[[x]] |> 
      purrr::map_df(\(y) {
        trial <- as.numeric(sub(".+_(.+)d.+", "\\1", y))
        if(trial %% 5 == 0) message("   index ", trial)
        df <- out2_resp1[[trial]]
        X <- df |> 
          select(As:Sn) |> 
          as.matrix.data.frame()
        C <- df |>
          bind_cols(
            data.frame(model.matrix(~ race-1, data = 
                                      mutate(df, race = as.factor(race))))
          ) |> 
          select(race2:race5, smoke:bmi) |> 
          as.matrix.data.frame()
        Y <- df$y
        
        bsr <- read_rds(y)
        
        result1 <- trivarsurf_bsr(bsr, X = X, C = C, j1 = 4, j2 = 5, j3 = 6,
                                  gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                  quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[4], 
                 j2 = cnames[5], 
                 j3 = cnames[6])
        result2 <- trivarsurf_bsr(bsr, X = X, C = C, j1 = 5, j2 = 6, j3 = 4,
                                  gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                  quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[5], 
                 j2 = cnames[6], 
                 j3 = cnames[4])
        result3 <- trivarsurf_bsr(bsr, X = X, C = C, j1 = 6, j2 = 4, j3 = 5,
                                  gridLength = 50, quantile_j2 = c(0.1, 0.5, 0.9), 
                                  quantile_rest = 0.5) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)), 
                 df = bsr$ns, 
                 j1 = cnames[6], 
                 j2 = cnames[4], 
                 j3 = cnames[5])
        
        rm(bsr)
        return(bind_rows(result1, result2, result3))
      }) |> 
      mutate(case = x)
  })
write_csv(slg_triv, "sim/bsr_lg/triv_expresp.csv")
```

Next, we extract output from stratified models. 

```{r}
# naive small, chemxcov models
mlr_sm_re <- read_rds("sim/mlr_mods_sm_re.RDS")

mlrsmre_pval <- 1:400 |> 
  map_df(\(x) {
    mod <- mlr_sm_re[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(mlrsmre_pval, "sim/_mlr/pvalsmre.csv")

# naive large, chemxcov models
mlr_lg_re <- read_rds("sim/mlr_mods_lg_re.RDS")

mlrlgre_pval <- 1:400 |> 
  map_df(\(x) {
    mod <- mlr_lg_re[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(mlrlgre_pval, "sim/_mlr/pvallgre.csv")

# oracle small, chemxcov models
orac_sm_re <- read_rds("sim/oracle_mods_sm_re.RDS")

oracsmre_pval <- 1:400 |> 
  map_df(\(x) {
    mod <- orac_sm_re[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(oracsmre_pval, "sim/_oracle/pvalsmre.csv")

# oracle large, chemxcov models
orac_lg_re <- read_rds("sim/oracle_mods_lg_re.RDS")

oraclgre_pval <- 1:400 |> 
  map_df(\(x) {
    mod <- orac_lg_re[[x]]
    data.frame(summary(mod)$coefficients) |> 
      rownames_to_column(var = "var") |> 
      select(var, p = 5) |> 
      mutate(case = x)
  })
write_csv(oraclgre_pval, "sim/_oracle/pvallgre.csv")
```

```{r}
#########
# extract bkmr stratified
#########

## small ##

list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ksmre <- list_files[grepl("_rslurm_ksmre", list_files)]

ksmre_subf <- list.dirs(list_ksmre, full.names = TRUE, recursive = TRUE)
ksmre_mod <- ksmre_subf[grepl("mods", ksmre_subf)]

ksmre_labels <- gsub("\\D", "", ksmre_mod)
ksmre_labels <- ifelse(ksmre_labels == "", 1, as.numeric(ksmre_labels))

# get paths
ksmre_paths <- ksmre_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ksmre_labels)

one <- read_rds(ksmre_paths[[1]][[1]])
oney <- SingVarRiskSummaries(one[[2]], q.fixed = 0.5)
onex <- SingVarRiskSummaries(one[[2]], which.z = 4, q.fixed = 0.5)
onez <- PredictorResponseUnivar(one[[2]], which.z = 4)

# extract PIPs
ksmre_pips <- names(ksmre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    ksmre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:6 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(variable = NA, PIP = NA, race = z)
            } else { 
              # get pips
              df <- ExtractPIPs(mod) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(ksmre_pips, "sim/re/ksmre_pips.csv")

# get confidence intervals
ksmre_ints <- names(ksmre_paths) |> 
  purrr::map_df(\(x) { # for each case
    ksmre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:6 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(est = NA, sd = NA, race = z)
            } else { 
              # compute estimate of 0.75 vs. 0.25 quantiles
              df <- SingVarRiskSummaries(mod, which.z = 4, q.fixed = 0.5) |> 
                select(est, sd) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(ksmre_ints, "sim/re/ksmre_ints.csv")

# get exposure response relationships
ksmre_univ <- names(ksmre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    ksmre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:6 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(z1 = NA, est = NA, se = NA, race = z)
            } else { 
              # compute estimated Hg-response relationship
              df <- PredictorResponseUnivar(mod, which.z = 4) |> 
                select(z1 = z, est, se) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(ksmre_univ, "sim/re/ksmre_expresp.csv")  

## large ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_klgre <- list_files[grepl("_rslurm_klgre", list_files)]

klgre_subf <- list.dirs(list_klgre, full.names = TRUE, recursive = TRUE)
klgre_mod <- klgre_subf[grepl("mods", klgre_subf)]

klgre_labels <- gsub("\\D", "", klgre_mod)
klgre_labels <- ifelse(klgre_labels == "", 1, as.numeric(klgre_labels))

# get paths
klgre_paths <- klgre_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = klgre_labels)

# get pips
klgre_pips <- names(klgre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    klgre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:5 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(variable = NA, PIP = NA, race = z)
            } else { 
              # get pips
              df <- ExtractPIPs(mod) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(klgre_pips, "sim/re/klgre_pips.csv")

# get confidence intervals
klgre_ints <- names(klgre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    klgre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:5 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(est = NA, sd = NA, race = z)
            } else { 
              # compute estimate of 0.75 vs. 0.25 quantiles
              df <- SingVarRiskSummaries(mod, which.z = 4, q.fixed = 0.5) |> 
                select(est, sd) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(klgre_ints, "sim/re/klgre_ints.csv")

# get exposure response relationships
klgre_univ <- names(klgre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    klgre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:5 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(z1 = NA, est = NA, se = NA, race = z)
            } else { 
              # compute estimated Hg-response relationship
              df <- PredictorResponseUnivar(mod, which.z = 4) |> 
                select(z1 = z, est, se) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(klgre_univ, "sim/re/klgre_expresp.csv")  
```

```{r}
######
# extract bsr stratified
#######

# first, move all stratified models into one folder
# because we ran each model as one separate job

## small ##

# extracting file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_bsri <- list_files[grepl("_rslurm_ssmre(\\d+)_", list_files)]

bsri_subf <- list.dirs(list_bsri, full.names = TRUE, recursive = TRUE)
bsri_mod <- bsri_subf[grepl("mods", bsri_subf)]
bsri_time <- bsri_subf[grepl("times", bsri_subf)]

# copy mods to correct folder 
for (f in bsri_mod) {
  file.copy(from = list.files(f, full.names = TRUE),
            to   = paste0(substr(f, 1, 15), "/mods"))
}

## large ##
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_bsri <- list_files[grepl("_rslurm_slgre(\\d+)_", list_files)]

bsri_subf <- list.dirs(list_bsri, full.names = TRUE, recursive = TRUE)
bsri_mod <- bsri_subf[grepl("mods", bsri_subf)]
bsri_time <- bsri_subf[grepl("times", bsri_subf)]

# copy mods to correct folder
for (f in bsri_mod) {
  file.copy(from = list.files(f, full.names = TRUE),
            to   = paste0(substr(f, 1, 15), "/mods"))
}

# next, extract results

# load in functions for extracting results
source("extract_fxns.R")

## small ##

# read back in data
out1_resp1_re <- read_rds("sim/sim_resp_sm_re.RDS")

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ssmre <- list_files[grepl("_rslurm_ssmre", list_files)]

ssmre_subf <- list.dirs(list_ssmre, full.names = TRUE, recursive = TRUE)
ssmre_mod <- ssmre_subf[grepl("mods", ssmre_subf)]

ssmre_labels <- gsub("\\D", "", ssmre_mod)
ssmre_labels <- ifelse(ssmre_labels == "", 1, as.numeric(ssmre_labels))

# get paths
ssmre_paths <- ssmre_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ssmre_labels)

# extract PIPs
ssmre_pips <- names(ssmre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    ssmre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        
        1:6 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod) == "logical") {
              result <- data.frame(variable = NA, PIP = NA, 
                                   df = NA, race = z)
            } else {
              result <- data.frame(variable = cnames, PIP = mod$MainPIP) |>
                mutate(df = mod$ns, race = z)
            }
            return(result)
          }) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(ssmre_pips, "sim/re/ssmre_pips.csv")
write.csv(ssmre_pips, "sim/re/ssmre_pips.csv")

# get exposure response relationships
ssmre_univ <- names(ssmre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    ssmre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        trial <- as.numeric(sub(".+_(.+)d.+", "\\1", y))
        if(trial %% 10 == 0) message("index ", y)
        df <- out1_resp1_re[[trial]]
        X <- df |> 
          select(As:Sn) |> 
          as.matrix.data.frame()
        C <- df |> 
          select(smoke:bmi) |> 
          as.matrix.data.frame()
        Y <- df$y
        
        list_mod <- read_rds(y)
        1:6 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(j1val = NA, est = NA, 
                               lower = NA, upper = NA, race = z)
            } else { 
              # compute estimated Hg-response relationship
              df <- univarsurf_bsr(mod, X, C, j1 = 4) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(ssmre_univ, "sim/re/ssmre_expresp.csv")  

## large ##

# read back in data
out2_resp1_re <- read_rds("sim/sim_resp_lg_re.RDS")

list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_slgre <- list_files[grepl("_rslurm_slgre", list_files)]

slgre_subf <- list.dirs(list_slgre, full.names = TRUE, recursive = TRUE)
slgre_mod <- slgre_subf[grepl("mods", slgre_subf)]

slgre_labels <- gsub("\\D", "", slgre_mod)
slgre_labels <- ifelse(slgre_labels == "", 1, as.numeric(slgre_labels))

# get paths
slgre_paths <- slgre_mod |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = slgre_labels)

# extract PIPs
slgre_pips <- names(slgre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    slgre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        list_mod <- read_rds(y)
        1:6 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod) == "logical") {
              result <- data.frame(variable = NA, PIP = NA, 
                                   df = NA, race = z)
            } else {
              result <- data.frame(variable = cnames, PIP = mod$MainPIP) |>
                mutate(df = mod$ns, race = z)
            }
            return(result)
          }) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(slgre_pips, "sim/re/slgre_pips.csv")

# get exposure response relationships
slgre_univ <- names(slgre_paths) |> 
  purrr::map_df(\(x) { # for each case
    message("starting ", x)
    slgre_paths[[x]] |> 
      purrr::map_df(\(y) { # for each trial
        trial <- as.numeric(sub(".+_(.+)d.+", "\\1", y))
        if(trial %% 10 == 0) message("index ", y)
        df <- out2_resp1_re[[trial]]
        X <- df |> 
          select(As:Sn) |> 
          as.matrix.data.frame()
        C <- df |> 
          select(smoke:bmi) |> 
          as.matrix.data.frame()
        Y <- df$y
        
        list_mod <- read_rds(y)
        1:5 |> # for each stratified model
          purrr::map_df(\(z) {
            mod <- list_mod[[z]]
            if(class(mod)[1] == "logical") { # if output failed
              df <- data.frame(j1val = NA, est = NA, 
                               lower = NA, upper = NA, race = z)
            } else { 
              # compute estimated Hg-response relationship
              df <- univarsurf_bsr(mod, X, C, j1 = 4) |> 
                mutate(race = z)
            }
            # print(df)
            return(df)
          }) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)))
      }) |> 
      mutate(case = x)
  })
write_csv(slgre_univ, "sim/re/slgre_expresp.csv")  
```

Finally, we extract information on run-times for BKMR and BSR. Note that run-times for MLRs were already combined in one file earlier, as they were all run on one job sent to the HPC. 

```{r}
######
# BKMR run times
#####

## small ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ksm <- list_files[grepl("_rslurm_bkmr_sm", list_files)]

ksm_subf <- list.dirs(list_ksm, full.names = TRUE, recursive = TRUE)
ksm_times <- ksm_subf[grepl("times", ksm_subf)]

ksm_labelt <- gsub("\\D", "", ksm_times)
ksm_labelt <- ifelse(ksm_labelt == "", 1, as.numeric(ksm_labelt))

# get paths
ksm_patht <- ksm_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ksm_labelt)

times <- names(ksm_patht) |> 
  map_df(\(x) {
    ksm_patht[[x]] |> 
      map_df(\(y) {
        # time = read_rds(y)
        # print(time)
        return(data.frame(
          time = read_rds(y),
          trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y))))
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/bkmr_sm/times.RDS")

## large ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_klg <- list_files[grepl("_rslurm_bkmr_lg", list_files)]

klg_subf <- list.dirs(list_klg, full.names = TRUE, recursive = TRUE)
klg_times <- klg_subf[grepl("times", klg_subf)]

klg_labelt <- gsub("\\D", "", klg_times)
klg_labelt <- ifelse(klg_labelt == "", 1, as.numeric(klg_labelt))

# get paths
klg_patht <- klg_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = klg_labelt)

times <- names(klg_patht) |> 
  map_df(\(x) {
    klg_patht[[x]] |> 
      map_df(\(y) {
        # time = read_rds(y)
        # print(time)
        return(data.frame(
          time = read_rds(y),
          trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y))))
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/bkmr_lg/times.RDS")

######
# BSR run times
######

## small ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ssm <- list_files[grepl("_rslurm_bsr_sm", list_files)]

ssm_subf <- list.dirs(list_ssm, full.names = TRUE, recursive = TRUE)
ssm_times <- ssm_subf[grepl("times", ssm_subf)]

ssm_labelt <- gsub("\\D", "", ssm_times)
ssm_labelt <- ifelse(ssm_labelt == "", 1, as.numeric(ssm_labelt))

# get paths
ssm_patht <- ssm_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ssm_labelt)

times <- names(ssm_patht) |> 
  map_df(\(x) {
    ssm_patht[[x]] |> 
      map_df(\(y) {
        time = read_rds(y)
        # print(time)
        return(data.frame(
          time_selection = time[[1]],
          time = time[[2]], 
          trial = as.numeric(sub(".+_(.+)d.+", "\\1", y))))
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/bsr_sm/times.RDS")

## large ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_slg <- list_files[grepl("_rslurm_bsr_lg", list_files)]

slg_subf <- list.dirs(list_slg, full.names = TRUE, recursive = TRUE)
slg_times <- slg_subf[grepl("times", slg_subf)]

slg_labelt <- gsub("\\D", "", slg_times)
slg_labelt <- ifelse(slg_labelt == "", 1, as.numeric(slg_labelt))

# get paths
slg_patht <- slg_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = slg_labelt)

times <- names(slg_patht) |> 
  map_df(\(x) {
    slg_patht[[x]] |> 
      map_df(\(y) {
        time = read_rds(y)
        # print(time)
        return(data.frame(
          time_selection = time[[1]],
          time = time[[2]], 
          trial = as.numeric(sub(".+_(.+)d.+", "\\1", y))))
      }) |> 
      mutate(case = x)
  })
write_rds(times, "sim/bsr_lg/times.RDS")

######
# BKMR stratified run times
######

## small ##

# extract run times
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ksmre <- list_files[grepl("_rslurm_ksmre", list_files)]

ksmre_subf <- list.dirs(list_ksmre, full.names = TRUE, recursive = TRUE)
ksmre_times <- ksmre_subf[grepl("times", ksmre_subf)]

ksmre_labelt <- gsub("\\D", "", ksmre_times)
ksmre_labelt <- ifelse(ksmre_labelt == "", 1, as.numeric(ksmre_labelt))

# get paths
ksmre_patht <- ksmre_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ksmre_labelt)

times <- names(ksmre_patht) |> 
  map_df(\(x) {
    ksmre_patht[[x]] |> 
      map_df(\(y) {
        list_time <- read_rds(y)
        df <- 1:6 |> 
          map_df(\(z) {
            data.frame(time = list_time[[z]], 
                       race = z)
          })
        return(mutate(df, trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y))))
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/re/ksmre_times.RDS")

## large ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_slgre <- list_files[grepl("_rslurm_slgre", list_files)]

klgre_subf <- list.dirs(list_klgre, full.names = TRUE, recursive = TRUE)
klgre_times <- klgre_subf[grepl("times", klgre_subf)]

klgre_labelt <- gsub("\\D", "", klgre_times)
klgre_labelt <- ifelse(klgre_labelt == "", 1, as.numeric(klgre_labelt))

# get paths
klgre_patht <- klgre_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = klgre_labelt)

t <- read_rds(klgre_patht[[1]][1])

times <- names(klgre_patht) |> 
  map_df(\(x) {
    klgre_patht[[x]] |> 
      map_df(\(y) {
        # time = read_rds(y)
        # print(time)
        list_time <- read_rds(y)
        df <- 1:5 |> 
          map_df(\(z) {
            data.frame(time = list_time[[z]], 
                       race = z)
          })
        return(mutate(df, trial = as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", y))))
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/re/klgre_times.RDS")

########
# BSR stratified run-times
#######

## small ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_ssmre <- list_files[grepl("_rslurm_ssmre", list_files)]

ssmre_subf <- list.dirs(list_ssmre, full.names = TRUE, recursive = TRUE)
ssmre_times <- ssmre_subf[grepl("times", ssmre_subf)]

ssmre_labelt <- gsub("\\D", "", ssmre_times)
ssmre_labelt <- ifelse(ssmre_labelt == "", 1, as.numeric(ssmre_labelt))

# get paths
ssmre_patht <- ssmre_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = ssmre_labelt)

times <- names(ssmre_patht) |> 
  map_df(\(x) {
    ssmre_patht[[x]] |> 
      map_df(\(y) {
        list_time = read_rds(y)
        df <- 1:5 |> 
          map_df(\(z) {
            data.frame(time_selection = list_time[[z]][[1]], 
                       time = list_time[[z]][[2]], 
                       race = z)
          }) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)))
        return(df)
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/re/ssmre_times.RDS")

## large ##

# file names
list_files <- list.dirs(".", full.names = FALSE, recursive = FALSE)
list_slgre <- list_files[grepl("_rslurm_slgre", list_files)]

slgre_subf <- list.dirs(list_slgre, full.names = TRUE, recursive = TRUE)
slgre_times <- slgre_subf[grepl("times", slgre_subf)]

slgre_labelt <- gsub("\\D", "", slgre_times)
slgre_labelt <- ifelse(slgre_labelt == "", 1, as.numeric(slgre_labelt))

# get paths
slgre_patht <- slgre_times |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = slgre_labelt)

times <- names(slgre_patht) |> 
  map_df(\(x) {
    slgre_patht[[x]] |> 
      map_df(\(y) {
        list_time = read_rds(y)
        df <- 1:5 |> 
          map_df(\(z) {
            data.frame(time_selection = list_time[[z]][[1]], 
                       time = list_time[[z]][[2]], 
                       race = z)
          }) |> 
          mutate(trial = as.numeric(sub(".+_(.+)d.+", "\\1", y)))
        return(df)
      }) |> 
      mutate(case = x)
  })

write_rds(times, "sim/re/slgre_times.RDS")
```


### Presenting results

Here, we create the tables and figures presented in Chapter \@ref(results). Code for supplemental results included in Appendix \@ref(suppresults) are also included in this section. 

We start with some setup. 

```{r}
library(tidyverse)
library(latex2exp)

# set up ------------------------------------------------------------------

# set theme for plots
theme_set(theme_light())
theme_update(
  panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  strip.background = element_rect(color="gray", fill="white"), 
  strip.text = element_text(color = "gray30")
)

# create labeller
equations1 <-  c(TeX("No inter", output = "character"), 
                 TeX("0.35Hg$*$Ni"), TeX("0.13Hg$*($Ni$-1)^2$"), 
                 TeX("0.35Cd$*$As"), TeX("0.125Cd$*($As$-1)^2$"), 
                 TeX("0.3Ni$*$Co"), TeX("0.1Ni$*($Co$-1)^2$"), 
                 TeX("0.3Hg$*$Ni$*$Tl"), TeX("0.09Hg$*($Ni$-1)^2*$Tl"), 
                 TeX("0.7Hg$*$Ni"), TeX("0.26Hg$*($Ni$-1)^2$"), 
                 TeX("0.7Cd$*$As"), TeX("0.25Cd$*($As$-1)^2$"), 
                 TeX("0.6Ni$*$Co"), TeX("0.2Ni$*($Co$-1)^2$"), 
                 TeX("0.6Hg$*$Ni$*$Tl"), TeX("0.18Hg$*($Ni$-1)^2*$Tl"))
namesa <- c(1, 2, 4, 6, 8, 10, 12, 14, 16, 3, 5, 7, 9, 11, 13, 15, 17)
appendera <- function(string) {
  return(equations1[match(string, namesa)])
}

# identify true significance based on variable name
get_sign <- function(case, chem) {
  case_when(
    chem %in% c("Hg", "Ni", "Sb", "Sn") ~ TRUE, 
    case %in% 6:9 & chem %in% c("Cd", "As") ~ TRUE, 
    case %in% 10:13 & chem == "Co" ~ TRUE, 
    case %in% 14:17 & chem == "Tl" ~ TRUE, 
    .default = FALSE
  )
}

# identify true significance based on index (BSR)
get_sign_bsr <- function(case, chem) {
  case_when(
    case %in% 2:5 & chem %in% c(4, 5) ~ TRUE, 
    case %in% 6:9 & chem %in% c(1, 2) ~ TRUE, 
    case %in% 10:13 & chem %in% c(3, 5) ~ TRUE, 
    case %in% 14:17 & chem %in% c(4, 5, 6) ~ TRUE, 
    .default = FALSE
  )
}

# identify true significance for race by ethnicity models
getsign_re <- function(chem) {
  return(chem %in% c("Hg", "Ni", "Sb", "Sn"))
}

# go from index of race to name
which_race <- function(race) {
  case_when(
    race == 1 ~ "Non-Hisp. white", 
    race == 2 ~ "Non-Hisp. black", 
    race == 3 ~ "Non-Hisp. other", 
    race == 4 ~ "Hispanic born in US", 
    race == 5 ~ "Hispanic born outside US",
    race == 6 ~ "Collapsed non-Hisp."
  )
}

# go from index of race to size of category
size_race <- function(race) {
  case_when(
    race == 1 ~ "16", 
    race == 2 ~ "27", 
    race == 3 ~ "13", 
    race == 4 ~ "87", 
    race == 5 ~ "109",
    race == 6 ~ "56"
  )
}
```

This code creates output for the base case. 

```{r}
# base case ---------------------------------------------------------------

# smaller size
nsm_pval <- read_csv("sim/_mlr/pvalsm.csv")
osm_pval <- read_csv("sim/_oracle/pvalsm.csv")
ksm_pips <- read_csv("sim/bkmr_sm/pips.csv")
ssm_pips <- read_csv("sim/bsr_sm/pips.csv")

# p-value visualization
osm_pvalc <- osm_pval |> 
  mutate(var = case_when(
    grepl("Ni", var) ~ "Ni*", 
    grepl("Sn", var) ~ "Sn*", 
    grepl("I\\(Sb", var) ~ "Sb^2", 
    .default = var
  )) |> 
  filter(var %in% c("Hg", "Ni*", "Tl", "Pb", "Mo", "Sn*", "Sb^2")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = TRUE, 
         mod = "Oracle MLR")
nsm_pvalc <- nsm_pval |> 
  filter(var %in% c("As", "Cd", "Co", "Hg", "Ni", 
                    "Tl", "Pb", "Mo", "Sb", "Sn")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var), 
         mod = "Naive MLR")

base_mlrs <- bind_rows(nsm_pvalc, osm_pvalc) |> 
  filter(case == 1)

p1 <- base_mlrs |> 
  ggplot(aes(var, p)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_pointrange(aes(color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  labs(y = "p-value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical") +
  facet_grid(.~mod, scales = "free_x", space = "free") 

# pip visualization
base_pips <- bind_rows(
  mutate(ksm_pips, mod = "BKMR"), 
  mutate(ssm_pips, mod = "BSR")
) |> 
  filter(case == 1) |> 
  mutate(sign = get_sign(case, variable))

p2 <- base_pips |> 
  ggplot(aes(variable, PIP)) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey30") +
  geom_pointrange(aes(color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  labs(y = "PIP distribution", 
       color = "Truly significant", 
       x = "Chemical") +
  facet_wrap(~mod, scales = "free_x") 


# larger size
nlg_pval <- read_csv("sim/_mlr/pvallg.csv")
olg_pval <- read_csv("sim/_oracle/pvallg.csv")
klg_pips <- read_csv("sim/bkmr_lg/pips.csv")
slg_pips <- read_csv("sim/bsr_lg/pips.csv")

# p-val visualization
nlg_pvalc <- nlg_pval |> 
  filter(var %in% c("As", "Cd", "Co", "Hg", "Ni", 
                    "Tl", "Pb", "Mo", "Sb", "Sn")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var), 
         mod = "Naive MLR")
olg_pvalc <- olg_pval |> 
  mutate(var = case_when(
    grepl("Ni", var) ~ "Ni*", 
    grepl("Sn", var) ~ "Sn*", 
    grepl("I\\(Sb", var) ~ "Sb^2", 
    .default = var
  )) |> 
  filter(var %in% c("Hg", "Ni*", "Tl", "Pb", "Mo", "Sn*", "Sb^2")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = TRUE, 
         mod = "Oracle MLR")

base_mlrl <- bind_rows(nlg_pvalc, olg_pvalc) |> 
  filter(case == 1)

p3 <- base_mlrl |> 
  ggplot(aes(var, p)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_pointrange(aes(color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  labs(y = "p-value distribution", 
       color = "Truly significant", 
       x = "Chemical") +
  facet_grid(.~mod, scales = "free_x", space = "free") 

# pip visualization
base_pipl <- bind_rows(
  mutate(klg_pips, mod = "BKMR"), 
  mutate(slg_pips, mod = "BSR")
) |> 
  filter(case == 1) |> 
  mutate(sign = get_sign(case, variable))

p4 <- base_pipl |> 
  ggplot(aes(variable, PIP)) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey30") +
  geom_pointrange(aes(color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  labs(y = "PIP distribution", 
       color = "Truly significant", 
       x = "Chemical") +
  facet_wrap(~mod, scales = "free_x") 

# plot grid
pone <- cowplot::plot_grid(
  p1 + theme(legend.position = "none"),
  p2 + theme(legend.position = "none"),
  p3 + theme(legend.position = "none"),
  p4 + theme(legend.position = "none"), 
  labels = c("a", "c", "b", "d"), nrow = 2, rel_widths = c(4, 5)
)
pone

legend <- cowplot::get_legend(p1)

# stitch together
cowplot::plot_grid(pone, legend, rel_widths = c(5, 0.5))
ggsave("index/figures/ch4_basecasesig.png", width = 9, height = 5)
```

```{r}
# create table of sensitivities
base_mlr <- bind_rows(
  mutate(base_mlrs, size = "Small"), 
  mutate(base_mlrl, size = "Large")
)

sum_base_mlr <- base_mlr |> 
  group_by(mod, size, var, sign) |> 
  summarize(sensitivity = sum(p < 0.05)/n())

base_bay <- bind_rows(
  mutate(base_pips, size = "Small"), 
  mutate(base_pipl, size = "Large")
)

sum_base_bay <- base_bay |> 
  rename(var = variable) |> 
  group_by(mod, size, var, sign) |> 
  summarize(sensitivity = sum(PIP >= 0.5)/n()) 

sum_base <- bind_rows(sum_base_mlr, sum_base_bay)
write_csv(sum_base, "index/data/base_sens.csv")

base_sens <- read_csv("data/base_sens.csv")

base_sens2 <- base_sens |> 
  mutate(var = gsub("[^[:alpha:]]","", var), 
         mod = factor(mod, levels = c("Naive MLR", "Oracle MLR", "BKMR", "BSR"))) |> 
  arrange(desc(sign), var, mod, desc(size)) |> 
  select(-sign) |> 
  pivot_wider(names_from = var, values_from = sensitivity)

base_mod_ord <- table(base_sens2$mod)

options(knitr.kable.NA = '-')
base_sens2 |> 
  select(-mod) |> 
  kbl(booktabs = TRUE, escape = FALSE, 
      col.names = c("", names(base_sens2)[3:12]),
      align = "lcccccccccc",
      caption = "Sensitivity and false discovery rate (FDR) of chemicals in base case scenario.") |> 
  column_spec(1, width = "6em") |>
  add_header_above(header = c(" " = 1, "Sensitivity" = 4, "FDR" = 6)) |>
  pack_rows(index = base_mod_ord) 
```

This code formats results for the naive MLR on scenarios with interactions between chemicals.

```{r}
# naive mlr ---------------------------------------------------------------

# p-values small
nsm_pval <- read_csv("sim/_mlr/pvalsm.csv")
nsm_pvalc <- nsm_pval |> 
  filter(var %in% c("As", "Cd", "Co", "Hg", "Ni", 
                    "Tl", "Pb", "Mo", "Sb", "Sn")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var), 
         mod = "Naive MLR")
nsm_pvalc_sens <- nsm_pvalc |> 
  mutate(imp = p < 0.05) |> 
  group_by(case, var) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2), 
            upper = quantile(p, 0.75))

# line plot of p-values
nsm_pvalc |> 
  filter(case != 1) |> 
  ggplot(aes(x = var, y = p)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(nsm_pvalc_sens, case != 1), 
             mapping = aes(x = var, y = upper+0.1, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(0.05, "lines")) +
  geom_pointrange(aes(color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(y = "p-value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical") +
  facet_wrap(~case, 
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed))) 
ggsave("index/figures/ch4_nsm_univ_pval.png", width = 7.5, height = 5)

# p-values large
nlg_pval <- read_csv("sim/_mlr/pvallg.csv")
nlg_pvalc <- nlg_pval |> 
  filter(var %in% c("As", "Cd", "Co", "Hg", "Ni", 
                    "Tl", "Pb", "Mo", "Sb", "Sn")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var), 
         mod = "Naive MLR")
nlg_pvalc_sens <- nlg_pvalc |> 
  mutate(imp = p < 0.05) |> 
  group_by(case, var) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2), 
            upper = quantile(p, 0.75))

# line plot of p-values
nlg_pvalc |> 
  filter(case != 1) |> 
  ggplot(aes(x = var, y = p)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(nlg_pvalc_sens, case != 1), 
           mapping = aes(x = var, y = upper+0.1, label = sensitivity), 
           size = 2, label.size = NA, label.padding = unit(0.05, "lines")) +
  geom_pointrange(aes(color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(y = "p-value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical") +
  facet_wrap(~case, 
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed))) 
ggsave("index/figures/ch4_nlg_univ_pval.png", width = 7.5, height = 5)

# save sensitivity as table
naive_all <- bind_rows(
  mutate(nsm_pvalc, size = "Small", mod = "Naive MLR"),
  mutate(nlg_pvalc, size = "Large", mod = "Naive MLR")
) |> 
  group_by(mod, case, size, var, sign) |> 
  summarize(sensitivity = sum(p < 0.05)/n())
write_csv(naive_all, "index/data/naive_sens.csv")
```

This code formats results for the oracle MLR in scenarios with interactions between chemicals. 

```{r}
# oracle mlr --------------------------------------------------------------

# p-values small
osm_pval <- read_csv("sim/_oracle/pvalsm.csv")
osm_pvalc <- osm_pval |> 
  mutate(var = case_when(
    grepl("Ni", var) ~ "Ni*", 
    grepl("Sn", var) ~ "Sn*", 
    grepl("I\\(Sb", var) ~ "Sb^2", 
    .default = var
  )) |> 
  filter(var %in% c("Hg", "Ni*", "Tl", "Pb", "Mo", "Sn*", "Sb^2")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = TRUE)
osm_pvalc_sens <- osm_pvalc |> 
  mutate(imp = p < 0.05) |> 
  group_by(case, var) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2), 
            upper = quantile(p, 0.75))

# line plot of p-values
osm_pvalc |>
  filter(case != 1) |>
  ggplot(aes(x = var, y = p)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(osm_pvalc_sens, case != 1), 
             mapping = aes(x = var, y = upper+0.12, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(0.05, "lines")) +
  geom_pointrange(aes(color = sign),
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median,
                  size = 0.2, color = "darkorange2") +
  labs(y = "p-value distribution",
       color = "Truly\nsignificant",
       x = "Chemical") +
  facet_wrap(~case,
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed)))
ggsave("index/figures/ch4_osm_univ_pval.png", width = 7.5, height = 5)

# interactions

keepnames <- c('(Intercept)', 'Hg', 'Sb', 'I(1/(1 + exp(-4 * Ni)))', 'Ni', 
               'I(Sb^2)', 'I(1/(1 + exp(-4 * Sn)))', 'age', 'bmi', 
               'race2', 'race3', 'race4', 'race5', 'smoke1', 'Cd', 'As', 'Co')

osm_pvali <- osm_pval |> 
  filter(!(var %in% keepnames)) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var))
osm_pvali_sens <- osm_pvali |> 
  mutate(imp = p < 0.05) |> 
  group_by(case, var) |> 
  summarize(sensitivity = sum(imp)/n())

# density plot of p-values
osm_pvali |>
  ggplot(aes(x = p)) +
  geom_density(color = "darkorange2", fill = "darkorange", alpha = 0.1) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "grey30") +
  labs(x = "p-value distribution") +
  facet_wrap(~case, scales = "free_y", 
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed)))
ggsave("index/figures/ch4_osm_biv_pval.png", width = 7.5, height = 5)

# put interactions and univ together
osm_comb <- bind_rows(
  mutate(osm_pvali, variable = "Int"), 
  mutate(osm_pvalc[osm_pvalc$case != 1, ], variable = var)
)

osm_comb |> 
  mutate(variable = factor(variable, levels = c(unique(osm_pvalc$var), "Int")), 
         interaction = (variable == "Int")) |> 
  ggplot(aes(x = variable, y = p, color = interaction)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_pointrange(stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2"))+
  labs(y = "p-value distribution", 
       color = "Interaction", 
       x = "Term") +
  facet_wrap(~case, 
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed))) 
ggsave("index/figures/ch4_osm_pval.png", width = 7.5, height = 5)

# p-values large
olg_pval <- read_csv("sim/_oracle/pvallg.csv")
olg_pvalc <- olg_pval |> 
  mutate(var = case_when(
    grepl("Ni", var) ~ "Ni*", 
    grepl("Sn", var) ~ "Sn*", 
    grepl("I\\(Sb", var) ~ "Sb^2", 
    .default = var
  )) |> 
  filter(var %in% c("Hg", "Ni*", "Tl", "Pb", "Mo", "Sn*", "Sb^2")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var))
olg_pvalc_sens <- olg_pvalc |> 
  mutate(imp = p < 0.05) |> 
  group_by(case, var) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2), 
            upper = quantile(p, 0.75))

# line plot of p-values
olg_pvalc |>
  filter(case != 1) |> 
  ggplot(aes(x = var, y = p)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(olg_pvalc_sens, case != 1), 
             mapping = aes(x = var, y = upper+0.1, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(0.05, "lines")) +
  geom_pointrange(stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median,
                  size = 0.2, color = "darkorange2") +
  labs(y = "p-value distribution",
       color = "Truly significant",
       x = "Chemical") +
  facet_wrap(~case,
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed)))
ggsave("index/figures/ch4_olg_univ_pval.png", width = 7.5, height = 5)

# interactions

keepnames <- c('(Intercept)', 'Hg', 'Sb', 'I(1/(1 + exp(-4 * Ni)))', 'Ni', 
               'I(Sb^2)', 'I(1/(1 + exp(-4 * Sn)))', 'age', 'bmi', 
               'race2', 'race3', 'race4', 'race5', 'smoke1', 'Cd', 'As', 'Co')

olg_pvali <- olg_pval |> 
  filter(!(var %in% keepnames)) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = get_sign(case, var))
olg_pvali_sens <- olg_pvali |> 
  mutate(imp = p < 0.05) |> 
  group_by(case, var) |> 
  summarize(sensitivity = sum(imp)/n())

# density plot of p-values
olg_pvali |>
  ggplot(aes(x = p)) +
  geom_density(color = "darkorange2", fill = "darkorange", alpha = 0.1) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "grey30") +
  labs(x = "p-value distribution") +
  facet_wrap(~case, scales = "free_y", 
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed)))
ggsave("index/figures/ch4_olg_biv_pval.png", width = 7.5, height = 5)

# put together
olg_comb <- bind_rows(
  mutate(olg_pvali, variable = "Int"), 
  mutate(olg_pvalc[olg_pvalc$case != 1, ], variable = var)
)

olg_comb |> 
  mutate(variable = factor(variable, levels = c(unique(olg_pvalc$var), "Int")), 
         interaction = (variable == "Int")) |> 
  ggplot(aes(x = variable, y = p, color = interaction)) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "grey30") +
  geom_pointrange(stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2"))+
  labs(y = "p-value distribution", 
       color = "Interaction", 
       x = "Term") +
  facet_wrap(~case, 
             labeller = labeller(
               case = as_labeller(appendera, default = label_parsed))) 
ggsave("index/figures/ch4_olg_pval.png", width = 7.5, height = 5)

# save sensitivity as table
oracle_all <- bind_rows(
  mutate(osm_comb, size = "Small", mod = "Oracle MLR"),
  mutate(olg_comb, size = "Large", mod = "Oracle MLR")
) |> 
  group_by(mod, case, size, var, variable) |> 
  summarize(sensitivity = sum(p < 0.05)/n())
write_csv(oracle_all, "index/data/oracle_sens.csv")
```

This code formats results from BKMR models in scenarios with interactions between chemicals. 

```{r}
# smaller size bkmr -------------------------------------------------------

# plot pips bkmr small
ksm_pips <- read_csv("sim/bkmr_sm/pips.csv")

ksm_pip_sig <- ksm_pips |> 
  mutate(sign = get_sign(case, variable))
ksm_pip_sen <- ksm_pips |> 
  mutate(imp = PIP >= 0.5) |> 
  group_by(case, variable) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2), 
            upper = quantile(PIP, 0.75))

# point and lineplot
ksm_pip_sig |> 
  filter(case != 1) |> 
  ggplot(aes(x = variable)) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(ksm_pip_sen, case != 1), 
             mapping = aes(x = variable, y = upper+0.1, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(0, "lines")) +
  geom_pointrange(aes(y = PIP, color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  facet_wrap(~case,
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + 
  labs(y = "PIP value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical")
ggsave("index/figures/ch4_ksm_univ_pips.png", width = 7.5, height = 5)

# plot bivariate relationships bkmr small
ksm_biv <- read_csv("sim/bkmr_sm/biv_expresp.csv")

# plot Hg and Ni
ksm_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(variable1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_ksm_biv_expresp_1.png", width = 6, height = 4)

# plot Cd and As
ksm_biv |> 
  filter(case %in% 6:9) |> 
  mutate(variable1 = ifelse(variable1 == "Cd", "Cd by As", "As by Cd"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-4, 4) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_ksm_biv_expresp_2.png", width = 6, height = 4)

# plot Ni and Co
ksm_biv |> 
  filter(case %in% 10:13) |> 
  mutate(variable1 = ifelse(variable1 == "Ni", "Ni by Co", "Co by Ni"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_ksm_biv_expresp_3.png", width = 6, height = 4)

# plot trivariate relationships bkmr small
ksm_triv <- read_csv("sim/bkmr_sm/triv_expresp.csv")
ksm_triv <- ksm_triv |> 
  mutate(variable1 = case_when(
    z1_name == "Hg" ~ "Hg by Ni + Tl", 
    z1_name == "Ni" ~ "Ni by Hg + Tl", 
    z1_name == "Tl" ~ "Tl by Hg + Ni"), 
  quantile = as.factor(z23_q)) 

ksm_triv |> 
  ggplot(aes(z1_val, est, color = quantile)) +
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) + 
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2+3\nquantile") +
  theme(strip.text.x = element_text(size = 7))
ggsave("index/figures/ch4_ksm_triv_expresp.png", width = 6, height = 4)

# one vs. other significant data
ksm_intb <- read_csv("sim/bkmr_sm/int_bivar.csv")

ksm_intb <- ksm_intb |> 
  mutate(cond = paste0(z1, "+", z2)) |> 
  rowwise() |> 
  mutate(signif = ifelse(
    between(0, est - 1.96*sd, est + 1.96*sd), FALSE, TRUE
  ))

# one vs. two others significant data
ksm_intt <- read_csv("sim/bkmr_sm/int_trivar.csv")

ksm_intt <- ksm_intt |> 
  mutate(cond = paste0(variable, " by ", fixedat1, "+", fixedat2)) |> 
  rowwise() |> 
  mutate(signif = ifelse( #bonferroni correction: critical value 2.39398
    between(0, est - 2.39398*sd, est + 2.39398*sd), FALSE, TRUE
  ))

# bivar and trivar together
int_combs <- bind_rows(
  select(ksm_intb, cond, trial, case, signif), 
  select(ksm_intt, cond, trial, case, signif)
)

# larger size bkmr --------------------------------------------------------

# plot pips bkmr large
klg_pips <- read_csv("sim/bkmr_lg/pips.csv")

klg_pip_sig <- klg_pips |> 
  mutate(sign = get_sign(case, variable))
klg_pip_sen <- klg_pips |> 
  mutate(imp = PIP >= 0.5) |> 
  group_by(case, variable) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2), 
            upper = quantile(PIP, 0.75))

# point and lineplot
klg_pip_sig |> 
  filter(case != 1) |> 
  ggplot(aes(x = variable)) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(klg_pip_sen, case != 1), 
             mapping = aes(x = variable, y = upper+0.1, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(.05, "lines")) +
  geom_pointrange(aes(y = PIP, color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  facet_wrap(~case,
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(y = "PIP value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical")
ggsave("index/figures/ch4_klg_univ_pips.png", width = 7.5, height = 5)

# plot bivariate relationships bkmr large
klg_biv <- read_csv("sim/bkmr_lg/biv_expresp.csv")

# plot Hg and Ni
klg_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(variable1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_klg_biv_expresp_1.png", width = 6, height = 4)

# plot Cd and As
klg_biv |> 
  filter(case %in% 6:9) |> 
  mutate(variable1 = ifelse(variable1 == "Cd", "Cd by As", "As by Cd"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-4, 4) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_klg_biv_expresp_2.png", width = 6, height = 4)

# plot Ni and Co
klg_biv |> 
  filter(case %in% 10:13) |> 
  mutate(variable1 = ifelse(variable1 == "Ni", "Ni by Co", "Co by Ni"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_klg_biv_expresp_3.png", width = 6, height = 4)

# plot trivariate relationships bkmr large
klg_triv <- read_csv("sim/bkmr_lg/triv_expresp.csv")
klg_triv <- klg_triv |> 
  mutate(variable1 = case_when(
    z1_name == "Hg" ~ "Hg by Ni + Tl", 
    z1_name == "Ni" ~ "Ni by Hg + Tl", 
    z1_name == "Tl" ~ "Tl by Hg + Ni"), 
    quantile = as.factor(z23_q)) 

klg_triv |> 
  ggplot(aes(z1_val, est, color = quantile)) +
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) + 
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2+3\nquantile") +
  theme(strip.text.x = element_text(size = 7))
ggsave("index/figures/ch4_klg_triv_expresp.png", width = 6, height = 4)

# one vs. other significant data
klg_intb <- read_csv("sim/bkmr_lg/int_bivar.csv")

klg_intb <- klg_intb |> 
  mutate(cond = paste0(z1, "+", z2)) |> 
  rowwise() |> 
  mutate(signif = ifelse(
    between(0, est - 1.96*sd, est + 1.96*sd), FALSE, TRUE
  ))

# one vs. two others significant data
klg_intt <- read_csv("sim/bkmr_lg/int_trivar.csv")

klg_intt <- klg_intt |> 
  mutate(cond = paste0(variable, " by ", fixedat1, "+", fixedat2)) |> 
  rowwise() |> 
  mutate(signif = ifelse( #bonferroni correction: critical value 2.39398
    between(0, est - 2.39398*sd, est + 2.39398*sd), FALSE, TRUE
  ))

# bivar and trivar together
int_combl <- bind_rows(
  select(klg_intb, cond, trial, case, signif),
  select(klg_intt, cond, trial, case, signif)
)

# bkmr combine sensitivity ------------------------------------------------

# univariate pips
bkmr_pips <- bind_rows(
  mutate(ksm_pips, size = "Small"), 
  mutate(klg_pips, size = "Large")
) |> 
  group_by(size, case, variable) |> 
  summarize(sensitivity = sum(PIP >= 0.5)/n()) |> 
  mutate(sign = get_sign(case, variable))
write_csv(bkmr_pips, "index/data/bkmr_pip_sens.csv")

# interactions
bkmr_comb <- bind_rows(
  mutate(int_combs, size = "Small"), 
  mutate(int_combl, size = "Large")
)

bkmr_sens <- bkmr_comb |> 
  group_by(size, case, cond) |> 
  summarize(sensitivity = sum(signif)/n())
write_csv(bkmr_sens, "index/data/bkmr_int_sens.csv")
```

This code formats results from BSR models in scenarios with interactions between chemcials. 

```{r}
# smaller size bsr --------------------------------------------------------

# plot pip's bsr small
ssm_pips <- read_csv("sim/bsr_sm/pips.csv")

ssm_pip_sig <- ssm_pips |> 
  mutate(sign = get_sign(case, variable))
ssm_pip_sen <- ssm_pips |> 
  mutate(imp = PIP >= 0.5) |> 
  group_by(case, variable) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2, 
                                      max = 2), 
            upper = quantile(PIP, 0.75))

# point and lineplot
ssm_pip_sig |> 
  filter(case != 1) |> 
  ggplot(aes(x = variable)) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(ssm_pip_sen, case != 1), 
             mapping = aes(x = variable, y = upper+0.1, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(0.05, "lines")) +
  geom_pointrange(aes(y = PIP, color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  facet_wrap(~case,
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  # scale_y_continuous(sec.axis = sec_axis(trans = ~., name = "Sensitivity")) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
        # legend.position = c(0.95, 0.05)) +
  labs(y = "PIP value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical")
ggsave("index/figures/ch4_ssm_univ_pips.png", width = 7.5, height = 5)

# plot bivariate pip's small
ssm_pipb <- read_csv("sim/bsr_sm/pip_biv.csv")

ssm_pipb |> 
  # filter(case == 2) |> 
  mutate(sign = get_sign_bsr(case, Var1) & get_sign_bsr(case, Var2), 
         inter = paste0(Var1, "_", Var2)) |> 
  ggplot(aes(x = inter)) + 
  geom_pointrange(aes(y = PIP, color = sign),
                  stat = "summary",
                  fun.min = function(z) {quantile(z, 0.25)},
                  fun.max = function(z) {quantile(z, 0.75)}, 
                  fun = median, 
                  size  = 0.05) +
  scale_color_manual(values = c("#92D0E4", "darkorange2")) +
  facet_wrap(~case, 
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position = c(0.9, 0.1)) +
  labs(y = "PIP value distribution", 
       color = "Truly significant", 
       x = NULL)
ggsave("index/figures/ch4_ssm_biv_pips.png", width = 7.5, height = 5)

# plot trivariate pip's small
ssm_pipt <- read_csv("sim/bsr_sm/pip_triv.csv")

ssm_pipt |> 
  ggplot(aes(x = "")) +
  geom_pointrange(aes(y = PIP),
                  stat = "summary",
                  fun.min = function(z) {quantile(z, 0.25)},
                  fun.max = function(z) {quantile(z, 0.75)}, 
                  fun = median, 
                  size  = 0.05) +
  facet_wrap(~case, 
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position = c(0.9, 0.1)) +
  labs(y = "PIP value distribution", 
       color = "Truly significant", 
       x = NULL)

# plot bivariate relationships bkmr small
ssm_biv <- read_csv("sim/bsr_sm/biv_expresp.csv")

# plot Hg and Ni
ssm_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(j1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-3, 9) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_ssm_biv_expresp_1.png", width = 6, height = 4)

# plot Cd and As
ssm_biv |> 
  filter(case %in% 6:9) |> 
  mutate(variable1 = ifelse(j1 == "Cd", "Cd by As", "As by Cd"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-2, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_ssm_biv_expresp_2.png", width = 6, height = 4)

# plot Ni and Co
ssm_biv |> 
  filter(case %in% 10:13) |> 
  mutate(variable1 = ifelse(j1 == "Ni", "Ni by Co", "Co by Ni"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  # ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_ssm_biv_expresp_3.png", width = 6, height = 4)

# plot trivariate relationships bsr small
ssm_triv <- read_csv("sim/bsr_sm/triv_expresp.csv")
ssm_triv <- ssm_triv |> 
  mutate(variable1 = case_when(
    j1 == "Hg" ~ "Hg by Ni + Tl", 
    j1 == "Ni" ~ "Ni by Hg + Tl", 
    j1 == "Tl" ~ "Tl by Hg + Ni"), 
    quantile = as.factor(j23quant)) 

ssm_triv |> 
  ggplot(aes(j1val, est, color = quantile)) +
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) + 
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2+3\nquantile") +
  theme(strip.text.x = element_text(size = 7))
ggsave("index/figures/ch4_ssm_triv_expresp.png", width = 6, height = 4)


# larger size bsr ---------------------------------------------------------

# plot pip's bsr large
slg_pips <- read_csv("sim/bsr_lg/pips.csv")

slg_pip_sig <- slg_pips |> 
  mutate(sign = get_sign(case, variable))
slg_pip_sen <- slg_pips |> 
  mutate(imp = PIP >= 0.5) |> 
  group_by(case, variable) |> 
  summarize(sensitivity = weights::rd(sum(imp)/n(), 2, max = 0), 
            upper = quantile(PIP, 0.75))

# point and lineplot
slg_pip_sig |> 
  filter(case != 1) |> 
  ggplot(aes(x = variable)) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "grey30") +
  geom_label(data = filter(slg_pip_sen, case != 1), 
             mapping = aes(x = variable, y = upper+0.1, label = sensitivity), 
             size = 2, label.size = NA, label.padding = unit(0.05, "lines")) +
  geom_pointrange(aes(y = PIP, color = sign), 
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.25)},
                  fun.max = function(z) {quantile(z,0.75)},
                  fun = median, 
                  size = 0.2) +
  facet_wrap(~case,
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  scale_color_manual(values = c("deepskyblue3", "darkorange2")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(y = "PIP value distribution", 
       color = "Truly\nsignificant", 
       x = "Chemical")
ggsave("index/figures/ch4_slg_univ_pips.png", width = 7.5, height = 5)

# plot bivariate pip's large
slg_pipb <- read_csv("sim/bsr_lg/pip_biv.csv")

slg_pipb |> 
  # filter(case == 2) |> 
  mutate(sign = get_sign_bsr(case, Var1) & get_sign_bsr(case, Var2), 
         inter = paste0(Var1, "_", Var2)) |> 
  ggplot(aes(x = inter)) + 
  geom_pointrange(aes(y = PIP, color = sign),
                  stat = "summary",
                  fun.min = function(z) {quantile(z, 0.25)},
                  fun.max = function(z) {quantile(z, 0.75)}, 
                  fun = median, 
                  size  = 0.05) +
  scale_color_manual(values = c("#92D0E4", "darkorange2")) +
  facet_wrap(~case, 
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position = c(0.9, 0.1)) +
  labs(y = "PIP value distribution", 
       color = "Truly significant", 
       x = NULL)
ggsave("index/figures/ch4_slg_biv_pips.png", width = 7.5, height = 5)

# plot trivariate pip's large
slg_pipt <- read_csv("sim/bsr_lg/pip_triv.csv")

slg_pipt |> 
  ggplot(aes(x = "")) +
  geom_pointrange(aes(y = PIP),
                  stat = "summary",
                  fun.min = function(z) {quantile(z, 0.25)},
                  fun.max = function(z) {quantile(z, 0.75)}, 
                  fun = median, 
                  size  = 0.05) +
  facet_wrap(~case, 
             labeller = as_labeller(appendera, 
                                    default = label_parsed)) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position = c(0.9, 0.1)) +
  labs(y = "PIP value distribution", 
       color = "Truly significant", 
       x = NULL)

# plot bivariate relationships bkmr large
slg_biv <- read_csv("sim/bsr_lg/biv_expresp.csv")

# plot Hg and Ni
slg_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(j1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-3, 9) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_slg_biv_expresp_1.png", width = 6, height = 4)

# plot Cd and As
slg_biv |> 
  filter(case %in% 6:9) |> 
  mutate(variable1 = ifelse(j1 == "Cd", "Cd by As", "As by Cd"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  ylim(-2, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_slg_biv_expresp_2.png", width = 6, height = 4)

# plot Ni and Co
slg_biv |> 
  filter(case %in% 10:13) |> 
  mutate(variable1 = ifelse(j1 == "Ni", "Ni by Co", "Co by Ni"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  # ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")
ggsave("index/figures/ch4_slg_biv_expresp_3.png", width = 6, height = 4)

# plot trivariate relationships bsr large
slg_triv <- read_csv("sim/bsr_lg/triv_expresp.csv")
slg_triv <- slg_triv |> 
  mutate(variable1 = case_when(
    j1 == "Hg" ~ "Hg by Ni + Tl", 
    j1 == "Ni" ~ "Ni by Hg + Tl", 
    j1 == "Tl" ~ "Tl by Hg + Ni"), 
    quantile = as.factor(j23quant)) 

slg_triv |> 
  ggplot(aes(j1val, est, color = quantile)) +
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) + 
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2+3\nquantile") +
  theme(strip.text = element_text(size = 7)) 
ggsave("index/figures/ch4_slg_triv_expresp.png", width = 6, height = 4)


# bsr combine sens --------------------------------------------------------

# univariate pips
bsr_pips <- bind_rows(
  mutate(ssm_pips, size = "Small"), 
  mutate(slg_pips, size = "Large")
) |> 
  group_by(size, case, variable) |> 
  summarize(sensitivity = sum(PIP >= 0.5)/n()) |> 
  mutate(sign = get_sign(case, variable))
write_csv(bsr_pips, "index/data/bsr_pip_sens.csv")

# interactions
cnames <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")

bsr_comb <- bind_rows(
  mutate(ssm_pipb, size = "Small"), 
  mutate(slg_pipb, size = "Large")
) |> 
  mutate(sign = get_sign_bsr(case, Var1) & get_sign_bsr(case, Var2), 
         v1 = cnames[Var1], v2 = cnames[Var2], 
         inter = paste0(v1, "-", v2)) |> 
  mutate(inter2 = ifelse(sign, inter, "none")) |> 
  group_by(size, case, inter2, sign) |> 
  summarize(sensitivity = sum(PIP >= 0.5)/n())
write_csv(bsr_comb, "index/data/bsr_int_sens.csv")
```

This code creates tables with univariate sensitivity and false discovery rates in scenarios with interactions between chemicals. 

```{r}
naive_sens <- read_csv("data/naive_sens.csv")
oracle_sens <- read_csv("data/oracle_sens.csv")
bkmr_sens <- read_csv("data/bkmr_pip_sens.csv")
bsr_sens <- read_csv("data/bsr_pip_sens.csv")

comb_sens <- bind_rows(
  rename(naive_sens, variable = var),
  filter(select(oracle_sens,-var), variable != "Int"),
  mutate(bkmr_sens, mod = "BKMR"),
  mutate(bsr_sens, mod = "BSR")
) |>
  filter(case != 1) |>
  mutate(
    variable = gsub("[^[:alpha:]]", "", variable),
    mod = factor(mod, levels = c("Naive MLR", "Oracle MLR", "BKMR", "BSR")) ,
    sign = ifelse(mod == "Oracle MLR", TRUE, sign),
    new_sign = factor(ifelse(
      variable %in% c("Hg", "Ni", "Sb", "Sn"),
      "Sen",
      "FDR"
    ), levels = c("Sen", "FDR")), 
    cond = case_when(
      case %in% 2:5 ~ "Hg-Ni",
      case %in% 6:9 ~ "Cd-As",
      case %in% 10:13 ~ "Ni-Co", 
      .default = "Hg-Ni-Tl"
    ),
    cond = factor(cond, levels = c("Hg-Ni", "Cd-As", "Ni-Co", "Hg-Ni-Tl")), 
    inter_type = ifelse(case %% 4 %in% 1:2, "Mult.", "Poly."),
    effect_size = factor(
      ifelse(case %% 2 == 1, "Higher", "Lower"),
      levels = c("Lower", "Higher")
    )
  ) |>
  group_by(cond, inter_type, effect_size, mod, size, new_sign) |> 
  summarize(detection = mean(sensitivity)) |> 
  arrange(new_sign, desc(size)) |> 
  pivot_wider(names_from = c(mod, size, new_sign), values_from = detection, 
              names_sep = " ") |> 
  ungroup()

comb_sens_ord <- table(comb_sens$cond)

# sensitivities
comb_sens |> 
  select(-cond) |> 
  select(1:10) |> 
  kbl(booktabs = TRUE, digits = 2, #align = "lcc",
      caption = "Overall sensitivity for univariate chemicals in all scenarios with interactions between chemicals. Multiplicative and polynomial are abbreviated mult. and poly., respectively.", 
      col.names = c("Type", "Effect size", 
                    rep(c("Naive", "Oracle", "BKMR", "BSR"), 2))
      ) |> 
  add_header_above(header = c(" " = 2, "Small (n=252)" = 4, "Large (n=1000)" = 4), bold = TRUE) |>
  pack_rows(index = comb_sens_ord) 

# false discovery rates
comb_sens |> 
  select(-cond) |>
  select(c(1, 2, 11:16)) |> 
  kbl(booktabs = TRUE, digits = 2, #align = "lcc",
      caption = "Overall false discovery rate for univariate chemicals in all scenarios with interactions between chemicals.", 
      col.names = c("Type", "Effect size", 
                    rep(c("Naive", "BKMR", "BSR"), 2))
      ) |> 
  add_header_above(header = c(" " = 2, "Small" = 3, "Large" = 3)) |>
  # add_header_above(header = c(" " = 2, "Sensitivity" = 8, "False discovery rate" = 6)) |> 
  pack_rows(index = comb_sens_ord) 
```

This code creates a figure with the full estimated exposure-response relationship output for Hg and Ni only, which is included in the main results section

```{r}
# HgNi only ---------------------------------------------------------------

# bivariate surfaces

# bkmr small
hgni3 <- ksm_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(variable1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  theme(strip.text = element_text(size = 8)) + 
  ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")

# bkmr large
hgni4 <- klg_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(variable1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(quantile)) |> 
  ggplot(aes(z1, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  theme(strip.text = element_text(size = 8)) + 
  ylim(-6, 6) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")

# bsr small
hgni5 <- ssm_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(j1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  theme(strip.text = element_text(size = 8)) + 
  ylim(-3, 9) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")

# bsr large
hgni6 <- slg_biv |> 
  filter(case %in% 2:5) |> 
  mutate(variable1 = ifelse(j1 == "Hg", "Hg by Ni", "Ni by Hg"), 
         quantile = as.factor(j2quant)) |> 
  ggplot(aes(j1val, est, color = quantile)) + 
  geom_line(aes(group = interaction(trial, quantile)), alpha = 0.2) +
  ggh4x::facet_grid2(variable1~case, scales = "free", independent = "x", 
                     labeller = labeller(
                       case = as_labeller(appendera, default = label_parsed))) +
  scale_color_manual(values = c("deepskyblue3", "palegreen3", "darkorange"), 
                     guide = guide_legend(override.aes = list(alpha = 1), 
                                          reverse = TRUE)) +
  theme(strip.text = element_text(size = 8)) + 
  ylim(-3, 9) +
  labs(x = "Chem 1 value",  
       y = "Estimated response", 
       color = "Chem 2\nquantile")

hgnitwo <- cowplot::plot_grid(
  hgni3 + theme(legend.position = "none"),
  hgni4 + theme(legend.position = "none"),
  hgni5 + theme(legend.position = "none"),
  hgni6 + theme(legend.position = "none"),
  labels = "auto", nrow = 2
)
hgnitwo

hgnilegend2 <- cowplot::get_legend(hgni3 + theme(legend.position = "bottom"))

# stitch together
cowplot::plot_grid(hgnitwo, hgnilegend2, nrow = 2, rel_heights = c(5, 0.4))
ggsave("index/figures/ch4_hgni_biv.png", width = 9, height = 6)
```

This code creates a table of sensitivities for two-way interactions between chemicals. 

```{r}
oracle_comb <- read_csv("data/oracle_sens.csv")
bkmr_comb <- read_csv("data/bkmr_int_sens.csv")
bsr_comb <- read_csv("data/bsr_int_sens.csv")

comb_int <- bind_rows(
  oracle_comb |> filter(variable == "Int") |> 
    select(-variable, cond = var), 
  bkmr_comb |> mutate(mod = "BKMR"), 
  bsr_comb |> mutate(mod = "BSR") |> filter(sign) |> rename(cond = inter2) |> select(-sign)
) |>
  filter(case %in% 2:13) |> 
  mutate(cond = gsub(":", "-", cond), 
         cond = gsub("\\+", "-", cond),
         cond = case_when(
           cond == "I(Hg * ((Ni - 1)^2))" ~ "Hg-Ni", 
           cond == "I(Cd * ((As - 1)^2))" ~ "Cd-As", 
           cond == "I(Ni * ((Co - 1)^2))" ~ "Ni-Co", 
           cond == "As-Cd" ~ "Cd-As", 
           cond == "Co-Ni" ~ "Ni-Co", 
           .default = cond
         ), 
         cond = factor(cond, levels = c("Hg-Ni", "Cd-As", "Ni-Co")), 
         inter_type = ifelse(case %in% c(2, 3, 6, 7, 10, 11), "Multiplicative", "Polynomial"), 
         effect_size = factor(ifelse(case %% 2 == 1, "Higher", "Lower"), 
                              levels = c("Lower", "Higher"))) |> 
  select(-case) |>
  arrange(desc(size)) |> 
  pivot_wider(names_from = c(mod, size), values_from = sensitivity, 
              names_sep = " ") |> 
  arrange(cond, inter_type, effect_size)

# create table
comb_int_ord <- table(comb_int$cond)
comb_int |> 
  select(-cond) |> 
  kbl(booktabs = TRUE, escape = FALSE, 
      align = "llcccccc", 
      caption = "Sensitivity to interactions in all scenarios with two-way interactions between exposures.", 
      col.names = c("Interaction type", "Effect size", rep(c("Oracle", "BKMR", "BSR"), 2))) |> 
  add_header_above(header = c(" " = 2, "Small (n=252)" = 3, "Large (n=1000)" = 3), bold = TRUE) |>
  pack_rows(index = comb_int_ord) |> 
  collapse_rows(columns = 1, valign = "middle", latex_hline = "linespace")
```

This code creates a flow chart of detection of univariate and interaction signals for scenarios with larger size datasets and higher effect size, multiplicative interactions between Cd and As and Ni and Co. 

```{r}
library(ggalluvial)

# Cd-As

# extract from bkmr
bkmr_comb1 <- bkmr_comb |> 
  filter(cond == "As+Cd", case == 7) |> 
  select(case, size, trial, sign = signif, variable = cond)
ksm_pip_cdas <- ksm_pip_sig |>
  filter(case == 7, variable %in% c("As", "Cd")) |> 
  mutate(size = "Small") |> 
  select(case, size, trial, PIP, variable) 
klg_pip_cdas <- klg_pip_sig |> 
  filter(case == 7, variable %in% c("As", "Cd")) |> 
  mutate(size = "Large") |> 
  select(case, size, trial, PIP, variable) 

# combine
bkmr_cdas <- bind_rows(bkmr_comb1, ksm_pip_cdas, klg_pip_cdas) |> 
  mutate(mod = "BKMR") 

# extract from bsr
bsr_comb1 <- bind_rows(
  mutate(ssm_pipb, size = "Small"), 
  mutate(slg_pipb, size = "Large")
) |> 
  mutate(sign = get_sign_bsr(case, Var1) & get_sign_bsr(case, Var2), 
         v1 = cnames[Var1], v2 = cnames[Var2], 
         inter = paste0(v1, "-", v2)) |> 
  mutate(inter2 = ifelse(sign, inter, "none")) 
ssm_pip_cdas <- ssm_pip_sig |> 
  filter(case == 7, variable %in% c("As", "Cd")) |> 
  mutate(mod = "BSR", size = "Small") |> 
  select(case, size, trial, PIP, variable)
slg_pip_cdas <- slg_pip_sig |> 
  filter(case == 7, variable %in% c("As", "Cd")) |> 
  mutate(mod = "BSR", size = "Large") |> 
  select(case, size, trial, PIP, variable)

# combine
bsr_cdas <- bsr_comb1 |> 
  filter(inter2 == "As-Cd", case == 7) |> 
  select(case, size, trial, PIP, variable = inter2) |> 
  bind_rows(ssm_pip_cdas, slg_pip_cdas) |> 
  mutate(mod = "BSR")

# bind Cd As together
all_cdas <- bind_rows(bkmr_cdas, bsr_cdas) |> 
  mutate(sign = ifelse(is.na(PIP), sign, PIP >= 0.5), 
         variable = gsub("\\+", "-", variable)) |> 
  select(-PIP) |> 
  pivot_wider(names_from = variable, values_from = sign) |> 
  mutate(univ = case_when(
    As & Cd ~ "As & Cd", 
    As | Cd~ "As only/\nCd only", 
    .default = "Neither"
  )) |> 
  rename(interaction = 5) |> 
  mutate(univ = factor(univ, levels = c("As & Cd", "As only/\nCd only", "Neither")), 
         interaction = factor(interaction, levels = c(TRUE, FALSE)))

# alluvial plot for cd as
large_cdas <- all_cdas |> 
  filter(size == "Large") |> 
  group_by(mod, univ, interaction) |> 
  count()
cdasp <- large_cdas |> 
  rename(Univariate = univ, Interaction = interaction)  |> 
  ggplot(aes(axis1 = Univariate, axis2 = Interaction, y = n)) +
  ggalluvial::geom_alluvium(aes(fill = mod), alpha = 0.4) +
  ggalluvial::geom_stratum(color = "gray50") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), 
            lineheight = 0.75) +
  scale_x_discrete(limits = c("Univariate", "Interaction"), expand = c(0.2, 0.05)) +
  scale_fill_manual(values = c("deepskyblue3", "darkorange")) +
  labs(fill = "Model")

# Ni-Co

# extract from bkmr
bkmr_comb2 <- bkmr_comb |> 
  filter(cond == "Co+Ni", case == 11) |> 
  select(case, size, trial, sign = signif, variable = cond)
ksm_pip_nico <- ksm_pip_sig |>
  filter(case == 11, variable %in% c("Ni", "Co")) |> 
  mutate(size = "Small") |> 
  select(case, size, trial, PIP, variable) 
klg_pip_nico <- klg_pip_sig |> 
  filter(case == 11, variable %in% c("Ni", "Co")) |> 
  mutate(size = "Large") |> 
  select(case, size, trial, PIP, variable) 

bkmr_nico <- bind_rows(bkmr_comb2, ksm_pip_nico, klg_pip_nico) |> 
  mutate(mod = "BKMR") 

# extract from bsr
bsr_comb2 <- bind_rows(
  mutate(ssm_pipb, size = "Small"), 
  mutate(slg_pipb, size = "Large")
) |> 
  mutate(sign = get_sign_bsr(case, Var1) & get_sign_bsr(case, Var2), 
         v1 = cnames[Var1], v2 = cnames[Var2], 
         inter = paste0(v1, "-", v2)) |> 
  mutate(inter2 = ifelse(sign, inter, "none")) 
ssm_pip_nico <- ssm_pip_sig |> 
  filter(case == 11, variable %in% c("Ni", "Co")) |> 
  mutate(mod = "BSR", size = "Small") |> 
  select(case, size, trial, PIP, variable)
slg_pip_nico <- slg_pip_sig |> 
  filter(case == 11, variable %in% c("Ni", "Co")) |> 
  mutate(mod = "BSR", size = "Large") |> 
  select(case, size, trial, PIP, variable)

bsr_nico <- bsr_comb2 |> 
  filter(inter2 == "Co-Ni", case == 11) |> 
  select(case, size, trial, PIP, variable = inter2) |> 
  bind_rows(ssm_pip_nico, slg_pip_nico) |> 
  mutate(mod = "BSR")

# bind together
all_nico <- bind_rows(bkmr_nico, bsr_nico) |> 
  mutate(sign = ifelse(is.na(PIP), sign, PIP >= 0.5), 
         variable = gsub("\\+", "-", variable)) |> 
  select(-PIP) |> 
  pivot_wider(names_from = variable, values_from = sign) |> 
  mutate(univ = case_when(
    Ni & Co ~ "Ni & Co", 
    Ni ~ "Ni only", 
    Co ~ "Co only",
    .default = "Neither"
  )) |> 
  rename(interaction = 5) |> 
  mutate(univ = factor(univ, levels = c("Ni & Co", "Ni only", "Co only", "Neither")), 
         interaction = factor(interaction, levels = c(TRUE, FALSE)))

# alluvial plot for Ni Co
large_nico <- all_nico |> 
  filter(size == "Large") |> 
  group_by(mod, univ, interaction) |> 
  count()
nicop <- large_nico |> 
  rename(Univariate = univ, Interaction = interaction)  |> 
  ggplot(aes(axis1 = Univariate, axis2 = Interaction, y = n)) +
  ggalluvial::geom_alluvium(aes(fill = mod), alpha = 0.4) +
  ggalluvial::geom_stratum(color = "gray50") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), 
            lineheight = 0.75) +
  scale_x_discrete(limits = c("Univariate", "Interaction"), expand = c(0.2, 0.05)) +
  scale_fill_manual(values = c("deepskyblue3", "darkorange")) +
  labs(fill = "Model")

# combine nico and cdas together
cowplot::plot_grid(cdasp + theme(legend.position = "none"),
                   nicop, rel_widths = c(4.5, 6), labels = "auto")
ggsave("index/figures/ch4_flowchartboth.png", width = 8, height = 4)
```

This code creates a table of false discovery rates for two-way interactions between chemicals. 

```{r}
# bkmr false discovery rates
ksmfdr<- read_csv("sim/bkmr_sm/int_bivarfull.csv")
klgfdr <- read_csv("sim/bkmr_lg/int_bivarfull.csv")

bkmr_comb_fdr <- bind_rows(
  mutate(ksmfdr, size = "Small"), 
  mutate(klgfdr, size = "Large")
) |> 
  rowwise() |> 
  mutate(inter1 = paste0(z1, "-", z2), 
         sign = ifelse(
           (inter1 == "Hg-Ni" & case %in% 2:5) | 
             (inter1 == "As-Cd" & case %in% 6:9) | 
             (inter1 == "Co-Ni" & case %in% 10:13), TRUE, FALSE
         ), 
         signif = ifelse(
           between(0, est - 1.96*sd, est + 1.96*sd), FALSE, TRUE
         ), 
         inter2 = ifelse(sign, inter1, "none")) |> 
  group_by(size, case, inter2, sign) |> 
  summarize(sensitivity = sum(signif)/n())

# bsr false discovery rates
bsr_comb_fdr <- read_csv("index/data/bsr_int_sens.csv")

# combine
fdr_comb <- bind_rows(
  mutate(bkmr_comb_fdr, mod = "BKMR"), 
  mutate(bsr_comb_fdr, mod = "BSR")
) |> 
  relocate(mod)
write_csv(fdr_comb, "index/data/comb_int_fdr.csv")

# read data back in
fdr_comb <- read_csv("data/comb_int_fdr.csv")

fdr_comb2 <- fdr_comb |>
  filter(inter2 == "none", case %in% 2:13) |>
  mutate(
    cond = case_when(
      case %in% 2:5 ~ "Hg-Ni",
      case %in% 6:9 ~ "Cd-As",
      case %in% 10:13 ~ "Ni-Co"
    ),
    cond = factor(cond, levels = c("Hg-Ni", "Cd-As", "Ni-Co")), 
    inter_type = ifelse(case %in% c(2, 3, 6, 7, 10, 11), "Multiplicative", "Polynomial"),
    effect_size = factor(
      ifelse(case %% 2 == 1, "Higher", "Lower"),
      levels = c("Lower", "Higher")
    )
  ) |> 
  select(-inter2, -sign, -case) |>  
  pivot_wider(names_from = c(mod, size), values_from = sensitivity) |> 
  arrange(cond, inter_type, effect_size) |> 
  relocate(cond, inter_type, effect_size, BKMR_Small, BSR_Small, BKMR_Large, BSR_Large)

# create table
fdr_ord <- table(fdr_comb2$cond)
fdr_comb2 |> 
  select(-cond) |> 
  kbl(booktabs = TRUE, escape = FALSE, 
      align = "llcccc", digits = 4, 
      caption = "False discovery rate of interactions in all scenarios with two-way interactions between exposures.", 
      col.names = c("Interaction type", "Effect size", rep(c("BKMR", "BSR"), 2))) |> 
  add_header_above(header = c(" " = 2, "Small (n=252)" = 2, "Large (n=1000)" = 2), bold = TRUE) |>
  pack_rows(index = fdr_ord) |> 
  collapse_rows(columns = 1, valign = "middle", latex_hline = "linespace")
```

This code creates a table of sensitivities for three-way interactions. 

```{r}
# get trivariate sensitivity from oracle, bkmr, bsr
oracle_senst <- bind_rows(
  filter(mutate(osm_comb, size = "Small"), case %in% 14:17), 
  filter(mutate(olg_comb, size = "Large"), case %in% 14:17)
) |> 
  filter(variable == "Int") |> 
  group_by(case, size) |> 
  summarize(sensitivity = sum(p < 0.05)/n()) |> 
  mutate(mod = "Oracle") |> 
  relocate(mod)
bkmr_senst <- bkmr_comb |> 
  filter(case %in% 14:17) |> 
  pivot_wider(names_from = cond, values_from = signif) |>
  mutate(signif = unname(pick(4) | pick(5) | pick(6))) |>
  rename(signif = 7) |>
  group_by(case, size) |>
  summarize(sensitivity = sum(signif)/n()) |>
  mutate(mod = "BKMR") |> 
  relocate(mod)
bsr_senst <- bind_rows(
  mutate(ssm_pipt, size = "Small"), 
  mutate(slg_pipt, size = "Large")
) |> 
  group_by(case, size) |> 
  summarize(sensitivity = sum(PIP >= 0.5)/n()) |> 
  mutate(mod = "BSR") |> 
  relocate(mod)

# bind together
all_senst <- bind_rows(oracle_senst, bkmr_senst, bsr_senst) |> 
  mutate(inter_type = ifelse(case %in% c(14, 15), "Multiplicative", "Polynomial"), 
         effect_size = ifelse(case %in% c(14, 16), "Lower", "Higher"))
write_csv(all_senst, "sim/tables/triv_sens.csv")

# read back in
triv <- read_csv("data/triv_sens.csv")

# create table
triv |> 
  select(-case) |> 
  pivot_wider(names_from = c(mod, size), values_from = sensitivity) |> 
  relocate(1, 2, 4, 6, 8, 3, 5, 7) |> 
  kbl(booktabs = TRUE, 
      caption = "Sensitivity to trivariate interactions between Hg, Ni, and Tl.", 
      col.names = c("Interaction type", "Effect size", rep(c("Oracle", "BKMR", "BSR"), 2))) |> 
  add_header_above(header = c(" " = 2, "Small (n=252)" = 3, "Large (n=1000)" = 3), bold = TRUE) |>
  collapse_rows(columns = 1, valign = "middle", latex_hline = "linespace")
```

This code formats results for scenarios with an interaction between race and Hg. 

```{r}
# naive -------------------------------------------------------------------

nsmre_pval <- read_csv("sim/_mlr/pvalsmre.csv")
nlgre_pval <- read_csv("sim/_mlr/pvallgre.csv")

# p-values small
nsmre_pvalc <- nsmre_pval |> 
  filter(var %in% c("As", "Cd", "Co", "Hg", "Ni", 
                    "Tl", "Pb", "Mo", "Sb", "Sn")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = getsign_re(var), 
         mod = "Naive MLR")

# p-values large
nlgre_pvalc <- nlgre_pval |> 
  filter(var %in% c("As", "Cd", "Co", "Hg", "Ni", 
                    "Tl", "Pb", "Mo", "Sb", "Sn")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = getsign_re(var), 
         mod = "Naive MLR")

# save sensitivity as table
naive_allre <- bind_rows(
  mutate(nsmre_pvalc, size = "Small", mod = "Naive MLR"),
  mutate(nlgre_pvalc, size = "Large", mod = "Naive MLR")
) |> 
  group_by(mod, case, size, var, sign) |> 
  summarize(sensitivity = sum(p < 0.05)/n())
write_csv(naive_allre, "index/data/naive_re_sens.csv")


# oracle ------------------------------------------------------------------

# interaction terms
keepnames <- c('(Intercept)', 'Hg', 'Sb', 'I(1/(1 + exp(-4 * Ni)))', 'Ni', 
               'I(Sb^2)', 'I(1/(1 + exp(-4 * Sn)))', 'age', 'bmi', 
               'race2', 'race3', 'race4', 'race5', 'smoke1', 'Cd', 'As', 'Co')

# small
osmre_pval <- read_csv("sim/_oracle/pvalsmre.csv")

# univariate p-values
osmre_pvalc <- osmre_pval |> 
  mutate(var = case_when(
    grepl("Ni", var) ~ "Ni*", 
    grepl("Sn", var) ~ "Sn*", 
    grepl("I\\(Sb", var) ~ "Sb^2", 
    .default = var
  )) |> 
  filter(var %in% c("Hg", "Ni*", "Tl", "Pb", "Mo", "Sn*", "Sb^2")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = TRUE)

osmre_pvali <- osmre_pval |> 
  filter(!(var %in% keepnames)) |> 
  mutate(trial = case, 
         case = ceiling(case/100))

# combine univariate and interactions
osmre_comb <- bind_rows(
  mutate(osmre_pvali, variable = "Int"), 
  mutate(osmre_pvalc, variable = var)
)

# large
olgre_pval <- read_csv("sim/_oracle/pvallgre.csv")

# univariate p-values
olgre_pvalc <- olgre_pval |> 
  mutate(var = case_when(
    grepl("Ni", var) ~ "Ni*", 
    grepl("Sn", var) ~ "Sn*", 
    grepl("I\\(Sb", var) ~ "Sb^2", 
    .default = var
  )) |> 
  filter(var %in% c("Hg", "Ni*", "Tl", "Pb", "Mo", "Sn*", "Sb^2")) |> 
  mutate(trial = case, 
         case = ceiling(case/100), 
         sign = TRUE)

olgre_pvali <- olgre_pval |> 
  filter(!(var %in% keepnames)) |> 
  mutate(trial = case, 
         case = ceiling(case/100))

# combine univariate and interactions
olgre_comb <- bind_rows(
  mutate(olgre_pvali, variable = "Int"), 
  mutate(olgre_pvalc, variable = var)
)

# combine both oracle outputs
oracle_re <- bind_rows(
  mutate(osmre_comb, size = "Small"), 
  mutate(olgre_comb, size = "Large")
) |> 
  select(size, case, trial, variable, p) |> 
  arrange(case, trial, desc(size))

write_csv(oracle_re, "index/data/oracle_re_sens.csv")

# bkmr --------------------------------------------------------------------

library(intervals)
# critical value of 2.57583 for bonferroni corrected 95% CI

# function for checking overlap of confidence intervals
check_overlap <- function(data) {
  num_na <- sum(is.na(data$lower))
  sign <- data$sign 
  unsign <- !(data$sign)
  sign_intervals <- Intervals(na.omit(data[sign, c("lower", "upper")]))
  unsign_intervals <- Intervals(na.omit(data[unsign, c("lower", "upper")]))
  return(data.frame(
    num_na = num_na,
    sig_overlaps = length(interval_overlap(sign_intervals, unsign_intervals)[[1]]), 
    insig_overlaps = (length(unlist(interval_overlap(unsign_intervals, unsign_intervals))) == 
                        (length(unsign_intervals)/2)^2)
  ))
}

# detection of interactions 

# small
ksmre_ints <- read_csv("sim/re/ksmre_ints.csv")

# uncollapsed
ksmre_det1 <- ksmre_ints |> 
  filter(race != 6) |> 
  mutate(lower = est - 2.57583*sd, 
         upper = est + 2.57583*sd, 
         sign = (case <= 2 & race == 2) | (case >= 3 & race == 5)) |> 
  group_by(case, trial) |> 
  group_modify(~ check_overlap(.))

# check number of models where at least one was unable to be fitted
table(ksmre_det1$num_na != 0)

# use collapsed
ksmre_det2 <- ksmre_ints |> 
  filter(race %in% c(4, 5, 6)) |> 
  mutate(lower = est - 2.57583*sd, 
         upper = est + 2.57583*sd, 
         sign = (case <= 2 & race == 6) | (case >= 3 & race == 5)) |> 
  group_by(case, trial) |> 
  group_modify(~ check_overlap(.))

# large
klgre_ints <- read_csv("sim/re/klgre_ints.csv")

klgre_det <- klgre_ints |> 
  mutate(lower = est - 2.57583*sd, 
         upper = est + 2.57583*sd, 
         sign = (case <= 2 & race == 2) | (case >= 3 & race == 5)) |> 
  group_by(case, trial) |> 
  group_modify(~ check_overlap(.))

# save the trials that produced significant results
klgre_det |> 
  filter(sig_overlaps != 4) |> 
  write_csv("sim/re/trials_klg_sig.csv")

# get sensitivity
ksmre_sens1 <- ksmre_det1 |> 
  group_by(case) |> 
  summarize(sens = sum((sig_overlaps/(4-num_na)) != 1 & insig_overlaps)/n()) |> 
  mutate(size = "Small uncollapsed")
ksmre_sens2 <- ksmre_det2 |> 
  group_by(case) |> 
  summarize(sens = sum((sig_overlaps/(2-num_na)) != 1 & insig_overlaps)/n()) |> 
  mutate(size = "Small collapsed")
# no trials that had a significant non-overlap AlSO had non-significant non-overlap
klgre_sens <- klgre_det |> 
  group_by(case) |> 
  summarize(sens = sum(sig_overlaps != 4 & insig_overlaps)/n()) |> 
  mutate(size = "Large")

# combine sensitivities together
bkmrre_senscomb <- bind_rows(ksmre_sens1, ksmre_sens2, klgre_sens) 
write_csv(bkmrre_senscomb, "index/data/bkmr_re_sens.csv")

# pip's
ksmre_pips <- read_csv("sim/re/ksmre_pips.csv")
klgre_pips <- read_csv("sim/re/klgre_pips.csv")

# summarize pip's
ksmre_pips2 <- ksmre_pips |> 
  filter(is.na(variable) | variable == "Hg") |> 
  group_by(case, race) |> 
  summarize(num_na = sum(is.na(variable))/100, 
            hg_detect = sum(PIP >= 0.5, na.rm = T)/100)

klgre_pips2 <- klgre_pips |> 
  filter(is.na(variable) | variable == "Hg") |> 
  group_by(case, race) |> 
  summarize(num_na = sum(is.na(variable))/n(), 
            hg_detect = sum(PIP >= 0.5, na.rm = T)/n())

bkmrre_pipscomb <- bind_rows(
  mutate(ksmre_pips2, size = "Small"), 
  mutate(klgre_pips2, size = "Large")
)  |> 
  mutate(which_race = which_race(race), 
         size_race = size_race(race))
write_csv(bkmrre_pipscomb, "index/data/bkmr_re_pips.csv")


# bsr ---------------------------------------------------------------------

# pip's

# pip's
ssmre_pips <- read_csv("sim/re/ssmre_pips.csv")
slgre_pips <- read_csv("sim/re/slgre_pips.csv")

# summarize pip's
ssmre_pips2 <- ssmre_pips |> 
  filter(is.na(variable) | variable == "Hg") |> 
  group_by(case, race) |> 
  summarize(num_na = sum(is.na(variable))/100, 
            hg_detect = sum(PIP >= 0.5, na.rm = T)/100)

slgre_pips2 <- slgre_pips |> 
  filter(is.na(variable) | variable == "Hg") |> 
  group_by(case, race) |> 
  summarize(num_na = sum(is.na(variable))/n(), 
            hg_detect = sum(PIP >= 0.5, na.rm = T)/n())

bsrre_pipscomb <- bind_rows(
  mutate(ssmre_pips2, size = "Small"), 
  mutate(slgre_pips2, size = "Large")
)  |> 
  mutate(which_race = which_race(race), 
         size_race = size_race(race))
write_csv(bsrre_pipscomb, "index/data/bsr_re_pips.csv")
```

This code creates a table of sensitivities for interactions between race and Hg. 

```{r}
# table
bkmr_re_sens <- read_csv("data/bkmr_re_sens.csv") |> 
  rename(sensitivity = sens)
oracle_re_int <- read_csv("data/oracle_re_sens.csv") |> 
  filter(variable == "Int") |> 
  group_by(size, case) |> 
  summarize(sensitivity = sum(p<0.05)/n()) |> 
  mutate(size = ifelse(size == "Small", "Small uncollapsed", size))

re_ints <- bind_rows(
  mutate(bkmr_re_sens, mod = "BKMR"), 
  mutate(oracle_re_int, mod = "Oracle MLR")
) |> 
  arrange(desc(size), desc(mod)) |> 
  pivot_wider(names_from = c(mod, size), values_from = sensitivity) |> 
  mutate(effect_size = ifelse(case %in% c(1, 3), "Lower", "Higher"), 
         case = ifelse(case %in% c(1, 2), 
                       paste0("Original n=27", footnote_marker_symbol(2)), 
                       paste0("Oirignal n=100", footnote_marker_symbol(3)))
         ) |> 
  relocate(case, effect_size)

re_ints |> kbl(booktabs = TRUE, escape = FALSE, 
      align = "llccccc", 
      caption = "Sensitivity to interactions between the categorical race variable and Hg.", 
      col.names = c("Interaction in", "Effect size", 
                    "Oracle", "BKMR", "BKMR",
                    "Oracle", "BKMR")
      ) |> 
  add_header_above(header = c(" " = 2, "Uncollapsed" = 2, 
                              "Collapsed*" = 1, 
                              " " = 2)) |> 
  add_header_above(header = c(" " = 2, "Small (n=252)" = 3, "Large (n=1000)" = 2), 
                   bold = TRUE) |>
  collapse_rows(columns = 1, valign = "middle", latex_hline = "linespace") |> 
  # column_spec(7, width = "6em") |>
  add_footnote(c("\"Collapsed\" refers to scenarios where the smallest three race categories are collapsed into one stratified model.", "Non-Hispanic black", "Hispanic born outside US"), notation = "symbol", threeparttable = TRUE)
```

This code plots the estimated exposure-response relationship in scenarios with an interaction between race and Hg.

```{r}
# exposure response relationship ------------------------------------------

#### BKMR #####

# small
ksmre_expresp <- read_csv("sim/re/ksmre_expresp.csv")
# large
klgre_expresp <- read_csv("sim/re/klgre_expresp.csv")
# combine
bkmr_re_expresp <- bind_rows(
  mutate(ksmre_expresp, size = "Small"), 
  mutate(klgre_expresp, size = "Large")
) |> 
  filter(race != 6) 

# first two cases
kre12 <- bkmr_re_expresp |> 
  filter(case <= 2) |> 
  mutate(which_race = which_race(race), 
         size_race = size_race(race), 
         size = factor(size, levels = c("Small", "Large"))) 

k12 <- kre12 |>
  mutate(
    race2 = case_when(race == 2 ~ 5,
                      race == 5 ~ 2,
                      .default = race),
    race2 = factor(
      race2,
      levels = c(1, 2, 3, 4, 5),
      labels = c(1, 5, 3, 4, 2)
    ), 
    case = factor(ifelse(case == 1, "Lower", "Higher"), 
                  levels = c("Lower", "Higher"))
  ) |> 
  ggplot(aes(z1, est, color = race2)) +
  geom_line(aes(group = interaction(trial, race2)), alpha = 0.15) +
  ylim(-8, 8) + 
  facet_grid(size ~ case) +
  scale_color_manual(values = rev(c("#F8766D", "#A3A500", "#00BF7D", "#00B0F6", "#E76BF3")), 
                     breaks = c(1, 2, 3, 4, 5)) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Hg", y = "Estimate", subtitle = "BKMR, interaction in Non-Hispanic black")

# second two cases
kre34 <- bkmr_re_expresp |> 
  filter(case > 2) |> 
  mutate(which_race = which_race(race), 
         size_race = size_race(race), 
         size = factor(size, levels = c("Small", "Large"))) 

k34 <- kre34 |>
  mutate(
    race2 = factor(
      race,
      levels = c(1, 2, 3, 4, 5),
    ), 
    case = factor(ifelse(case == 3, "Lower", "Higher"), 
                  levels = c("Lower", "Higher"))
  ) |> 
  ggplot(aes(z1, est, color = race2)) +
  geom_line(aes(group = interaction(trial, race2)), alpha = 0.15) +
  ylim(-8, 8) + 
  facet_grid(size ~ case) +
  scale_color_manual(values = rev(c("#F8766D", "#A3A500", "#00BF7D", "#00B0F6", "#E76BF3")), 
                     breaks = c(1, 2, 3, 4, 5)) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Hg", y = "Estimate", subtitle = "BKMR, interaction in Hispanic born outside US")


##### BSR ######

# small
ssmre_expresp <- read_csv("sim/re/ssmre_expresp.csv")
# large
slgre_expresp <- read_csv("sim/re/slgre_expresp.csv")
# combine
bsr_re_expresp <- bind_rows(
  mutate(ssmre_expresp, size = "Small"), 
  mutate(slgre_expresp, size = "Large")
) |> 
  filter(race != 6) 

# first two cases
sre12 <- bsr_re_expresp |> 
  filter(case <= 2) |> 
  mutate(which_race = which_race(race), 
         size_race = size_race(race), 
         size = factor(size, levels = c("Small", "Large"))) 

s12 <- sre12 |>
  mutate(
    race2 = case_when(race == 2 ~ 5,
                      race == 5 ~ 2,
                      .default = race),
    race2 = factor(
      race2,
      levels = c(1, 2, 3, 4, 5),
      labels = c(1, 5, 3, 4, 2)
    ), 
    case = factor(ifelse(case == 1, "Lower", "Higher"), 
                  levels = c("Lower", "Higher"))
  ) |> 
  ggplot(aes(j1val, est, color = race2)) +
  geom_line(aes(group = interaction(trial, race2)), alpha = 0.15) +
  ylim(-6, 12) +
  facet_grid(size ~ case) +
  scale_color_manual(values = rev(c("#F8766D", "#A3A500", "#00BF7D", "#00B0F6", "#E76BF3")), 
                     breaks = c(1, 2, 3, 4, 5)) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Hg", y = "Estimate", subtitle = "BSR, interaction in Non-Hispanic black")

# second two cases
sre34 <- bsr_re_expresp |> 
  filter(case > 2) |> 
  mutate(which_race = which_race(race), 
         size_race = size_race(race), 
         size = factor(size, levels = c("Small", "Large"))) 

s34 <- sre34 |>
  mutate(
    race2 = factor(
      race,
      levels = c(1, 2, 3, 4, 5),
      labels = c("Non-Hisp. white", "Non-Hisp. other", "Non-Hisp. black", 
                 "Hispanic born in US", "Hispanic born outside US")
    ), 
    case = factor(ifelse(case == 3, "Lower", "Higher"), 
                  levels = c("Lower", "Higher"))
  ) |> 
  ggplot(aes(j1val, est, color = race2)) +
  geom_line(aes(group = interaction(trial, race2)), alpha = 0.15) +
  ylim(-6, 12) +
  facet_grid(size ~ case) +
  scale_color_manual(values = rev(c("#F8766D", "#A3A500", "#00BF7D", "#00B0F6", "#E76BF3"))) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Hg", y = "Estimate", color = "Race", 
       subtitle = "BSR, interaction in Hispanic born outside US") +
  theme(legend.position = "bottom")

re_expresp <- cowplot::plot_grid(
  k12 + theme(legend.position = "none"),
  s12 + theme(legend.position = "none"), 
  k34 + theme(legend.position = "none"),
  s34 + theme(legend.position = "none"),
  nrow = 2
)

reerlegend <- cowplot::get_legend(s34)
cowplot::plot_grid(re_expresp, reerlegend, rel_heights = c(5, 0.35), ncol = 1)
ggsave("index/figures/ch4_re_expresp.png", width = 7.75, height = 6)
```

This code creates a table of sensitivities for the univariate Hg term in scenarios where it interacts with race. 

```{r}
# read in data
naive_re_sens <- read_csv("data/naive_re_sens.csv") |> 
  filter(var == "Hg") |> 
  select(-sign, -var)
oracle_re_sens <- read_csv("data/oracle_re_sens.csv") |> 
  filter(variable == "Hg") |> 
  group_by(size, case) |> 
  summarize(sensitivity = sum(p<0.05)/n())
bkmr_re_pips <- read_csv("data/bkmr_re_pips.csv") |> 
  rename(sensitivity = hg_detect) |> 
  select(-num_na)
bsr_re_pips <- read_csv("data/bsr_re_pips.csv") |> 
  filter(size != "Large" | race != 6) |> 
  rename(sensitivity = hg_detect) |> 
  select(-num_na)

# combine together
univ_re_comb <- bind_rows(
  naive_re_sens, 
  mutate(oracle_re_sens, mod = "Oracle MLR"), 
  mutate(bkmr_re_pips, mod = "BKMR"), 
  mutate(bsr_re_pips, mod = "BSR")
)

# pivot wider
univ_re_wide <- univ_re_comb |> 
  arrange(desc(size)) |> 
  pivot_wider(names_from = case, values_from = sensitivity) |> 
  mutate(
    which_race = gsub("Hispanic", "Hisp.", which_race), 
    race = ifelse(is.na(which_race), NA, 
                  paste0(which_race, " (n=", size_race, ")"))
  ) |> 
  select(-which_race, -size_race) |> 
  relocate(size)

# print
univre_ord <- table(univ_re_wide$size)[c(2, 1)]
options(knitr.kable.NA = '-')

univ_re_wide |> 
  select(-size) |> 
  kbl(booktabs = TRUE, escape = FALSE, 
      align = "llcccc", 
      caption = "Sensitivity for the univariate Hg term in all scenarios with an interaction between the categorical race covariate and Hg. Sensitivities for BKMR and BSR models are stratified by race.", 
      col.names = c("Model", "Race", rep(c("Lower", "Higher"), 2))
      ) |> 
  add_header_above(header = c(" " = 2, "Small race cat." = 2, "Large race cat." = 2), bold = TRUE) |>
  pack_rows(index = univre_ord) |> 
  collapse_rows(columns = 1, valign = "middle", latex_hline = "linespace")
```


## Code for Appendix \@ref(suppmethods)

Finally, we create the supplemental methods output that is included in Appendix \@ref(suppmethods).

<!-- in Appendix \@ref(appa). We start with code for the supplemental methods output  -->

First, we visualize relationships between significant univariate exposures and the response. 

```{r}
library(tidyverse)

p1 <- ggplot(NULL) +
  geom_function(fun = function(x) x, 
                color = "darkorchid1") +
  xlim(-2, 2) +
  labs(x = "Hg")

p2 <- ggplot(NULL) +
  geom_function(fun = function(x) 3/(1+exp(-4*x)), 
                color = "deepskyblue3") +
  xlim(-2, 2) +
  labs(x = "Ni")

p3 <- ggplot(NULL) +
  geom_function(fun = function(x) 1.5/(1+exp(-4*x)), 
                color = "darkorange") +
  xlim(-2, 2) +
  labs(x = "Sn")

p4 <- ggplot(NULL) +
  geom_function(fun = function(x) (x^2) + 0.5*x, 
                color = "coral1") +
  xlim(-2, 2) +
  labs(x = "Sb")

cowplot::plot_grid(p1, p2, p3, p4)
ggsave("index/figures/univariatelines.png", width = 6, height = 4)
```

Next, we visualize 3D surfaces for pair-wise interactions between exposures. 

```{r}
# load packages
library(tidyverse)
library(plotly)
# use reticulate to save plotly 3d plots
if(!require(reticulate)) {
  install.packages('reticulate')
  reticulate::install_miniconda()
  reticulate::conda_install('r-reticulate', 'python-kaleido')
  reticulate::conda_install('r-reticulate', 'plotly', channel = 'plotly')
  Sys.setenv(RETICULATE_PYTHON = 
               '/Users/elizabethzhang/Library/r-miniconda-arm64/envs/r-reticulate/bin/python')
  reticulate::use_miniconda('r-reticulate')
}
```


```{r}
# load in observed data
comb_small <- read_csv("madres_data/base_data.csv")

# log-transform and scale target data
comb_scale <- comb_small |> 
  mutate(across(10:19, ~scale(log(.)))) 

# check ranges of scaled predictors
range(comb_scale$Hg)
range(comb_scale$Ni)
range(comb_scale$Cd)
range(comb_scale$As)
range(comb_scale$Co)

# generate data covering 2d predictor surface
data <- expand.grid(x1 = seq(-3, 3, by = 0.1), 
                    x2 = seq(-3, 3, by = 0.1))
x1 <- data$x1
x2 <- data$x2

# function to create plot
create_plot <- function(xax, yax, Y, xname = NA, yname = NA) {
  plot_ly(x = ~xax, y = ~yax, z = ~Y, intensity = ~Y) |> 
    add_trace(type = "mesh3d") |> 
    layout(scene = list(
      xaxis = list(rangemode = "normal",
                   showgrid = FALSE,
                   showline = TRUE, 
                   mirror = TRUE, 
                   ticks = "outside", 
                   title = xname), 
      yaxis = list(rangemode = "normal", 
                   showgrid = FALSE,
                   showline = TRUE, 
                   mirror = TRUE, 
                   ticks = "outside", 
                   title = yname), 
      zaxis = list(rangemode = "normal", 
                   showgrid = FALSE,
                   showline = TRUE, 
                   mirror = TRUE, 
                   ticks = "outside", 
                   title = "Y"), 
      aspectmode = "cube"
    ))
}

##########
# marginally significant (Hg and Ni)
##########

# no interaction
y00 <- with(data, x1 + 3/(1+exp(-4*x2))) 
fig00 <- create_plot(x1, x2, y00, "Hg", "Ni")  |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = 0.1))))
fig00
save_image(fig00, "index/figures/surfaces/p00.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, smaller effect size
yam1 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.35*x1*x2) 
figam1 <- create_plot(x1, x2, yam1, "Hg", "Ni") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figam1
save_image(figam1, "index/figures/surfaces/am1.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, larger effect size
yam2 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.75*x1*x2) 
figam2 <- create_plot(x1, x2, yam2, "Hg", "Ni") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figam2
save_image(figam2, "index/figures/surfaces/am2.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, smaller effect size
yap1 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.13*x1*((x2-1)^2))
figap1 <- create_plot(x1, x2, yap1, "Hg", "Ni")|> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figap1
save_image(figap1, "index/figures/surfaces/ap1.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, larger effect size
yap2 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.26*x1*((x2-1)^2))
figap2 <- create_plot(x1, x2, yap2, "Hg", "Ni") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figap2
save_image(figap2, "index/figures/surfaces/ap2.png", 
           width = 720, height = 480, scale = 3)

##########
# marginally insignificant (Cd and As)
##########

# multiplicative interaction, smaller effect size
ybm1 <- with(data, 0.35*x1*x2) 
figbm1 <- create_plot(x1, x2, ybm1, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbm1
save_image(figbm1, "index/figures/surfaces/bm1.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, larger effect size
ybm2 <- with(data, 0.7*x1*x2) 
figbm2 <- create_plot(x1, x2, ybm2, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbm2
save_image(figbm2, "index/figures/surfaces/bm2.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, smaller effect size
ybp1 <- with(data, 0.125*x1*((x2-1)^2)) 
figbp1 <- create_plot(x1, x2, ybp1, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbp1
save_image(figbp1, "index/figures/surfaces/bp1.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, larger effect size
ybp2 <- with(data, 0.25*x1*((x2-1)^2))
figbp2 <- create_plot(x1, x2, ybp2, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbp2
save_image(figbp2, "index/figures/surfaces/bp2.png", 
           width = 720, height = 480, scale = 3)

##########
# highly correlated (Ni and Co)
##########

# multiplicative interaction, smaller effect size
ycm1 <- with(data, 3/(1+exp(-4*x2)) + 0.3*x1*x2) 
figcm1 <- create_plot(x1, x2, ycm1, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.2, y = 1.2, z = 1.5))))
figcm1
save_image(figcm1, "index/figures/surfaces/cm1.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, larger effect size
ycm2 <- with(data, 3/(1+exp(-4*x2)) + 0.6*x1*x2) 
figcm2 <- create_plot(x1, x2, ycm2, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.2, y = 1.2, z = 1.5))))
figcm2
save_image(figcm2, "index/figures/surfaces/cm2.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, smaller effect size
ycp1 <- with(data, 3/(1+exp(-4*x2)) + 0.1*x1*((x2-1)^2))
figcp1 <- create_plot(x1, x2, ycp1, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figcp1
save_image(figcp1, "index/figures/surfaces/cp1.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, larger effect size
ycp2 <- with(data, 3/(1+exp(-4*x2)) + 0.2*x1*((x2-1)^2))
figcp2 <- create_plot(x1, x2, ycp2, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figcp2
save_image(figcp2, "index/figures/surfaces/cp2.png", 
           width = 720, height = 480, scale = 3)
```

Next, we look at simulated exposure and covariate data for the larger size dataset. We also create the grid of density plots for Spearman's correlation values between exposures in the simulated smaller size datasets. 

```{r}
# create density plot of correlation for smaller size dataset
# read small size back in
out1 <- read_rds("sim/sim_preds_sm.RDS")

# extract correlation
cors <- out1 |> 
  purrr::map_df(\(x) {
    cor_mat <- cor(x[, 5:14], method = "spearman")
    cor_mat[lower.tri(cor_mat)] <- NA
    melt_cor <- reshape2::melt(cor_mat) |> 
      mutate(value = ifelse(value == 1, NA, value)) |> 
      na.omit() |> 
      mutate(sim = x$sim[1])
    return(melt_cor)
  })

# function for plotting x-axis
newbreaks <- function(lims) {
  range <- diff(lims)
  return(c(lims[1] + range/5, mean(lims), lims[2] - range/5))
}

# create grid of density plots
cors_dens <- cors |> 
  group_by(Var1, Var2) |> 
  mutate(mean = mean(value)) |> 
  ungroup() |> 
  ggplot(aes(x = value, fill = mean)) +
  geom_density() + 
  scale_x_continuous(breaks = newbreaks, 
                     labels = ~round(.x, 2)) +
  scale_y_continuous(position = "right") +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  ggh4x::facet_grid2(fct_rev(Var2) ~ Var1, scales = "free", independent = "x", 
                     render_empty = FALSE, switch = "both") +
  labs(x = TeX(r"( Spearman's $\rho$ )")) +
  theme(strip.placement = "outside", 
        strip.text.y.left = element_text(angle = 0), 
        legend.justification = c(1, 0),
        legend.position = c(0.9, 0.1),
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))
cors_dens

ggsave("index/figures/ch4_corr_sim.png", width = 10, height = 7)
```


```{r}
#############
# look at simulated data, larger size
#############

# read larger size data back in
out2 <- read_rds("sim/sim_preds_lg.RDS")
comb_sim2 <- bind_rows(out2)
```


```{r}
# density plots for exposures
name_order <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")
comb_sim2 |> 
  mutate(sim = as.factor(sim)) |> 
  select(5:15) |> 
  pivot_longer(cols = 1:10) |>
  mutate(name = factor(name, levels = name_order)) |> 
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  # reference observed densities
  geom_density(
    data = comb_log |> select(10:19) |> pivot_longer(cols = 1:10) |> 
      mutate(name = factor(name, levels = name_order)),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free")
# save
ggsave("index/figures/ch4_univ_exp_sim_lg.png", width = 6, height = 4)
```


```{r}
# density plot for continuous covariates
cov_sim_p2 <- comb_sim2 |> 
  mutate(sim = as.factor(sim)) |> 
  select(age, bmi, sim) |> 
  pivot_longer(cols = 1:2) |>
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  geom_density(
    data = comb_log |> select(age, bmi) |> pivot_longer(cols = 1:2),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free", ncol = 1)

# bar + violin plot for continuous covariates
cov_sim_q2 <- comb_sim2 |> 
  mutate(sim = as.factor(sim)) |> 
  select(sim, smoke, race) |> 
  mutate(smoke = ifelse(smoke == 0, "Never-exposed", "Ever-exposed"), 
         race = case_when(
           race == 1 ~ "Non-Hisp. white", 
           race == 2 ~ "Non-Hisp. black", 
           race == 3 ~ "Non-Hisp. other", 
           race == 4 ~ "Hispanic born\nin US", 
           race == 5 ~ "Hispanic born\noutside US"
         )) |> 
  pivot_longer(cols = 2:3) |> 
  group_by(sim, name, value) |> 
  summarize(prop = n()/1000) |> 
  mutate(value = factor(
    value, levels = rev(c("Never-exposed", "Ever-exposed",
                          "Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
                          "Hispanic born\nin US", "Hispanic born\noutside US"))
  )) |> 
  ggplot(aes(x = value, y = prop)) +
  geom_bar(data = df_forcovcat, aes(x = value, y = after_stat(prop), group = 1), 
           inherit.aes = FALSE, stat = "count", fill = "skyblue") +
  geom_violin(color = "gray30", fill = "gray", alpha = 0.25) + 
  facet_wrap(~name, scales = "free", ncol = 1) +
  coord_flip() +
  labs(x = NULL, y = "proportion")

# plot in grid and save
cowplot::plot_grid(cov_sim_p2, cov_sim_q2, labels = "auto", nrow = 1, 
                   rel_widths = c(0.4, 0.6))
ggsave("index/figures/ch4_univ_cov_sim_lg.png", width = 6, height = 4)
```


```{r}
# extract spearman's correlation from large simulated data
corl <- out2 |> 
  purrr::map_df(\(x) {
    cor_mat <- cor(x[, 5:14], method = "spearman")
    cor_mat[lower.tri(cor_mat)] <- NA
    melt_cor <- reshape2::melt(cor_mat) |> 
      mutate(value = ifelse(value == 1, NA, value)) |> 
      na.omit() |> 
      mutate(sim = x$sim[1])
    return(melt_cor)
  })

# grid of density plots of correlation in large simulated data
cors_dens2 <- corl |> 
  group_by(Var1, Var2) |> 
  mutate(mean = mean(value)) |> 
  ungroup() |> 
  ggplot(aes(x = value, fill = mean)) +
  geom_density() + 
  scale_x_continuous(breaks = newbreaks, 
                     labels = ~round(.x, 2)) +
  scale_y_continuous(position = "right") +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  ggh4x::facet_grid2(fct_rev(Var2) ~ Var1, scales = "free", independent = "x", 
                     render_empty = FALSE, switch = "both") +
  labs(x = TeX(r"( Spearman's $\rho$ )")) +
  theme(strip.placement = "outside", 
        strip.text.y.left = element_text(angle = 0), 
        legend.justification = c(1, 0),
        legend.position = c(0.9, 0.1),
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))

# heatmap of average correlation in large simulated data
cor_sim2 <- corl |> 
  group_by(Var1, Var2) |> 
  summarize(value = mean(value)) |> 
  mutate(label = round(value, 2)) |> 
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = label), size = 3.5) +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  coord_fixed() +
  labs(x = NULL, y = NULL, fill = TeX(r"( Mean Spearman's $\rho$ )")) +
  theme(
    panel.grid.major.x = element_line(color = "grey85",
                                      linewidth = 0.25,
                                      linetype = 2), 
    panel.border = element_blank(),
    legend.justification = c(1, 0),
    legend.position = c(0.9, 0.1),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))

# put original and simulated correlation heatmaps together
top_row2 <- cowplot::plot_grid(cor_orig, cor_sim2, labels = "auto", label_size = 16, 
                              nrow = 1, scale = 0.95)
# put original, simulated, and density plots of correlation together
cowplot::plot_grid(top_row2, cors_dens2, labels = c("", "c"), label_size = 16, 
                   nrow = 2, rel_heights = c(5, 7), scale = c(1, 0.95))
ggsave("index/figures/ch4_corr_lg_simorigdens.png", width = 10, height = 12)
```

Here, we create the visualization of $R^2$ values in multiple linear regressions with the true functional form of the chemicals specified, in order to ensure we are achieving a realistic signal-to-noise ratio. This code was run on the Amherst HPC RStudio server. 

```{r}
### smaller size

# read in simulated datasets
out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")
run_co_sm <- function() {
  # initialize vectors
  chems_oracle <- vector(mode = 'list', length = 1700) 
  names(chems_oracle) <- names(out1_resp1)
  
  for(i in 1:1700) {
    df <- out1_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    if(i <= 100) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + 
                                I(1/(1+exp(-4*Sn))), data = df)
    } else if (i <= 300) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg*Ni, data = df)
    } else if (i <= 500) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)), data = df)
    } else if (i <= 700) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Cd*As, data = df)
    } else if (i <= 900) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Cd*((As-1)^2)), data = df)
    } else if (i <= 1100) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Ni*Co, data = df)
    } else if (i <= 1300) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Ni*((Co-1)^2)), data = df)
    } else if (i <= 1500) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg:Ni:Tl, data = df)
    } else if (i <= 1700) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)*Tl), data = df)
    }
  }
  return(chems_oracle)
}

# send to hpc
cosjob <- slurm_call(
  run_mlr_sm, 
  global_objects = c('out1_resp1'),
  jobname = 'co_sm')

# get output
chem_oracle <- get_slurm_out(cosjob)
write_rds(chem_oracle, "sim/chem_oracle_sm.RDS")

### larger sample size

# read in simulated datasets
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_co_lg <- function() {
  # initialize vectors
  chems_onlyl <- vector(mode = 'list', length = 1700)
  names(chems_onlyl) <- names(out2_resp1)
  chems_oraclel <- vector(mode = 'list', length = 1700) 
  names(chems_oraclel) <- names(out2_resp1)
  
  for(i in 1:1700) {
    df <- out2_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    if(i <= 100) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + 
                                I(1/(1+exp(-4*Sn))), data = df)
    } else if (i <= 300) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg*Ni, data = df)
    } else if (i <= 500) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)), data = df)
    } else if (i <= 700) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Cd*As, data = df)
    } else if (i <= 900) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Cd*((As-1)^2)), data = df)
    } else if (i <= 1100) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Ni*Co, data = df)
    } else if (i <= 1300) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Ni*((Co-1)^2)), data = df)
    } else if (i <= 1500) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg:Ni:Tl, data = df)
    } else if (i <= 1700) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)*Tl), data = df)
    }
  }
  return(chems_oraclel)
}

# send to hpc
coljob <- slurm_call(
  run_co_lg, 
  global_objects = c('out2_resp1'),
  jobname = 'co_lg')

# get output
chem_oraclel <- get_slurm_out(coljob)
write_rds(chem_oraclel, "sim/chem_oracle_lg.RDS")
```


```{r}
# extract rsq from smaller size datasets
chem_mods <- read_rds("sim/mlr/chem_oracle_sm.RDS")
rsq_chem <- chem_mods |> 
  purrr::map_df(\(x) {
    data.frame(
      rsq = summary(x)$r.squared
    )
  }) |> 
  mutate(name = names(chem_mods))

# plot for smaller size
rsqsmplot <- rsq_chem |> 
  ggplot(aes(x = rsq)) +
  geom_density() + 
  facet_wrap(~name, 
             labeller = as_labeller(appender1, 
                                    default = label_parsed), 
             ncol = 4) +
  labs(y = "Density", x = latex2exp::TeX("R$^2$"))

# extract rsq from larger size datasets
chem_modl <- read_rds("sim/mlr/chem_oracle_lg.RDS")
rsq_cheml <- chem_modl |> 
  purrr::map_df(\(x) {
    data.frame(
      rsq = summary(x)$r.squared
    )
  }) |> 
  mutate(name = names(chem_modl))

# plot for larger size
rsqlgplot <- rsq_cheml |> 
  ggplot(aes(x = rsq)) +
  geom_density() + 
  facet_wrap(~name, 
             labeller = as_labeller(appender1, 
                                    default = label_parsed), 
             ncol = 4) +
  labs(y = "Density", x = latex2exp::TeX("R$^2$"))

# plot both in grid and save
cowplot::plot_grid(rsqsmplot, rsqlgplot, labels = "auto", nrow = 1)
ggsave("index/figures/chem_rsq.png", width = 12, height = 6)
```

We also look at selecting degrees of freedom in BSR using 5,000 vs. 50,000 MCMC iterations. Refer to the code for fitting BSR on the smaller size datasets for how the models for this test were run. 

```{r}
# extract names of files for 50,000 iterations
main_folder <- "sim/bsr_df_sm"
subfolders <- list.dirs(main_folder, full.names = TRUE, recursive = TRUE)
mod_subfolders <- subfolders[grepl("mods", subfolders)]
mod_labels <- gsub("\\D", "", mod_subfolders)
mod_labels <- ifelse(mod_labels == "", 1, as.numeric(mod_labels))

mod_paths <- mod_subfolders |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = mod_labels)

# extract WAIC values from model output
waic <- names(mod_paths) |> 
  purrr::map_df(\(x) {
    mod_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- data.frame(
          df = c(1, 2, 3, 4, 5), 
          waic = c(bsr[[1]]$waic, 
                   bsr[[2]]$waic, 
                   bsr[[3]]$waic, 
                   bsr[[4]]$waic, 
                   bsr[[5]]$waic), 
          trial = rep(substr(y, nchar(y) - 4, nchar(y) - 4))
        )
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })

write_csv(waic, "sim/tables/test_waic.csv")

# look at waic values
waic <- read_csv("sim/tables/test_waic.csv")

# select degrees of freedom that minimizes waic
min_waic <- waic |> 
  group_by(case, trial) |> 
  filter(waic == min(waic)) |> 
  arrange(as.numeric(case))

# extract names of files for 5,000 iterations (trial 2)
main_folder2 <- "sim/bsr_df_sm2"
subfolders2 <- list.dirs(main_folder2, full.names = TRUE, recursive = TRUE)
mod_subfolders2 <- subfolders2[grepl("mods", subfolders2)]
mod_labels2 <- gsub("\\D", "", substr(mod_subfolders2, 16, nchar(mod_subfolders2)))
mod_labels2 <- ifelse(mod_labels2 == "", 1, as.numeric(mod_labels2))

mod_paths2 <- mod_subfolders2 |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = mod_labels2)

# extract waic from model outputs
waic2 <- names(mod_paths2) |> 
  purrr::map_df(\(x) {
    mod_paths2[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- data.frame(
          df = c(1, 2, 3, 4, 5), 
          waic = c(bsr[[1]]$waic, 
                   bsr[[2]]$waic, 
                   bsr[[3]]$waic, 
                   bsr[[4]]$waic, 
                   bsr[[5]]$waic), 
          trial = rep(substr(y, nchar(y) - 4, nchar(y) - 4))
        )
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })

write_csv(waic2, "sim/tables/test_waic2.csv")

# compare them
waic <- read_csv("sim/tables/test_waic.csv")
waic2 <- read_csv("sim/tables/test_waic2.csv")
waic_comb <- waic |> 
  mutate(iter = 1) |> 
  bind_rows(mutate(waic2, iter = 2))

# create plot
waic_comb |> 
  filter(trial <= 5) |> 
  mutate(df = as.factor(df), 
         iter = factor(ifelse(iter == 1, "F", "P"), levels = c("P", "F"))) |> 
  ggplot(aes(x = iter, y = waic, color = df)) +
  geom_point() +
  geom_line(aes(group = df)) + 
  ggh4x::facet_grid2(paste0("Trial ", trial) ~ case, 
                     scales = "free_y", independent = "y") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(), 
        plot.caption = element_text(hjust = 0, size = 7)) +
  labs(y = "WAIC", x = "# MCMC iterations (F = 50,000, P = 5,000)", 
       color = "Degrees\nfreedom",
       caption = paste0(
         "Scenarios are labelled in the top strip as follows:\n", 
         "1 = base case; 2 = HgNi mult. small; 3 = HgNi mult. large; ", 
         "4 = HgNi poly. small; 5 = HgNi poly. large; ", 
         "6 = CdAs mult. small; 7 = CdAs mult. large;", 
         "8 = CdAs poly. small; 9 = CdAs poly. large;\n", 
         "10 = NiCo mult. small; 11 = NiCo mult. large; ", 
         "12 = NiCo poly. small; 13 = NiCo poly. large; ", 
         "14 = HgNiTl mult. small; 15 = HgNiTl mult. large; ", 
         "16 = HgNiTl poly. small; 17 = HgNiTl poly. large"))

ggsave("index/figures/test_waic2.png", height = 6, width = 9)

# get proportion of correctly selected df's
waic_min <- waic_comb |> 
  mutate(iter = ifelse(iter == 1, "full", "partial")) |> 
  arrange(iter, case, trial) |> 
  filter(trial <= 5) |> 
  group_by(iter, trial, case) |> 
  filter(waic == min(waic)) |> 
  ungroup() |> 
  pivot_wider(id_cols = c(trial, case), 
              names_from = iter, values_from = df) |> 
  mutate(equal = (full == partial))
mean(waic_min$equal)  
```

We check convergence using trace plots for a selection of BKMR and BSR models. 

```{r}
library(bkmr)
library(NLinteraction)

# bkmr fits
bkmr_sm_am2_203 <- readRDS("testing/bkmr_sm_am2_203.RDS")
bkmr_lg_am2_284 <- readRDS("testing/bkmr_lg_am2_284.RDS")

# bsr fits
bsr_sm_am2_203df2 <- readRDS("testing/bsr_sm_am2_203df2.RDS")
bsr_lgf_am2_284df2 <- readRDS("testing/bsr_lgf_am2_284df2.RDS")

# bkmr sm
png("index/figures/traceplots/bksm_traceplot.png", width = 8, height = 6, units = "in", res = 360)
par(mfrow = c(2, 2))
TracePlot(fit = bkmr_sm_am2_203, par = "beta") # prior probability
TracePlot(fit = bkmr_sm_am2_203, par = "sigsq.eps") # variance of residuals
TracePlot(fit = bkmr_sm_am2_203, par = "r", comp = 1) # prob of each
TracePlot(fit = bkmr_sm_am2_203, par = "r", comp = 5)
dev.off()

# bkmr lg
png("index/figures/traceplots/bklg_traceplot.png", width = 8, height = 6, units = "in", res = 360)
par(mfrow = c(2, 2))
TracePlot(fit = bkmr_lg_am2_284, par = "beta")
TracePlot(fit = bkmr_lg_am2_284, par = "sigsq.eps")
TracePlot(fit = bkmr_lg_am2_284, par = "r", comp = 1)
TracePlot(fit = bkmr_lg_am2_284, par = "r", comp = 5)

# bsr sm
h <- bsr_sm_am2_203df2$posterior

png("index/figures/traceplots/bssm_traceplot.png", width = 8, height = 6, units = "in", res = 360)
par(mfrow = c(2, 2))
htau <- t(h[["tau"]][, , 1])
plot(htau[, 1], type = "l", 
     main = paste0("(tau = ", round(mean(htau[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(htau[, 1]), col = "blue", lwd = 2)

hsigma <- t(h[["sigma"]])
plot(hsigma[, 1], type = "l", 
     main = paste0("(sigma = ", round(mean(hsigma[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(hsigma[, 1]), col = "blue", lwd = 2)

hzeta1 <- t(h[["zeta"]][, , 1, 2])
plot(hzeta1[, 1], type = "l", 
     main = paste0("(zeta1 = ", round(mean(hzeta1[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(hzeta1[, 1]), col = "blue", lwd = 2)

hzeta5 <- t(h[["zeta"]][, , 5, 2])
plot(hzeta5[, 1], type = "l", 
     main = paste0("(zeta5 = ", round(mean(hzeta5[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(hzeta5[, 1]), col = "blue", lwd = 2)
dev.off()

# bsr lg
h <- bsr_lgf_am2_284df2$posterior

png("index/figures/traceplots/bslg_traceplot.png", width = 8, height = 6, units = "in", res = 360)
par(mfrow = c(2, 2))
htau <- t(h[["tau"]][, , 1])
plot(htau[, 1], type = "l", 
     main = paste0("(tau = ", round(mean(htau[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(htau[, 1]), col = "blue", lwd = 2)

hsigma <- t(h[["sigma"]])
plot(hsigma[, 1], type = "l", 
     main = paste0("(sigma = ", round(mean(hsigma[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(hsigma[, 1]), col = "blue", lwd = 2)

hzeta1 <- t(h[["zeta"]][, , 1, 2])
plot(hzeta1[, 1], type = "l", 
     main = paste0("(zeta1 = ", round(mean(hzeta1[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(hzeta1[, 1]), col = "blue", lwd = 2)

hzeta5 <- t(h[["zeta"]][, , 5, 2])
plot(hzeta5[, 1], type = "l", 
     main = paste0("(zeta5 = ", round(mean(hzeta5[,1]), 2), ")"), 
     xlab = "scan", ylab = "parameter value")
abline(h = mean(hzeta5[, 1]), col = "blue", lwd = 2)
dev.off()

# put all together

library(magick)

# list of input files
file_list <- c("index/figures/traceplots/bksm_traceplot.png", 
               "index/figures/traceplots/bklg_traceplot.png", 
               "index/figures/traceplots/bssm_traceplot.png", 
               "index/figures/traceplots/bslg_traceplot.png")

# output file name
output_file <- "index/figures/traceplots/bksm_traceplotmerged.png"

# merge images
merge_and_save <- function(file_list, output_file) {
  images <- image_read(file_list)
  
  # two columns
  top_row <- image_append(images[1:2], stack = TRUE)
  bottom_row <- image_append(images[3:4], stack = TRUE)
  
  # combine columns
  combined_image <- image_append(c(top_row, bottom_row), stack = FALSE)
  
  # add labels
  combined_image <- image_annotate(combined_image, "a", location = "+30+20", 
                                   size = 120, color = "black", font = "Roboto", weight = 700)
  combined_image <- image_annotate(combined_image, "b", location = "+2900+20", 
                                   size = 120, color = "black", font = "Roboto", weight = 700)
  combined_image <- image_annotate(combined_image, "c", location = "+30+2110", 
                                   size = 120, color = "black", font = "Roboto", weight = 700)
  combined_image <- image_annotate(combined_image, "d", location = "+2900+2110", 
                                   size = 120, color = "black", font = "Roboto", weight = 700)
  
  image_write(combined_image, path = output_file, format = "png")
}

merge_and_save(file_list, output_file)
```


