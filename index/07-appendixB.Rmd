# Code

This second appendix includes all of the R chunks of code that were hidden throughout the document.

<!-- ## In the main file \@ref(ref-labels): -->

<!-- ```{r ref.label = 'include_packages', results = 'hide', echo = TRUE} -->
<!-- ``` -->

```{r, include = FALSE}
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, size = 'scriptsize')
```

## Code for Section \@ref(bayes):

The code for this section generates a toy example, used to demonstrate the kernel machine regression and spline regression techniques. 

```{r}
#load packages
library(tidyverse)
library(stats)
library(splines)
```

```{r}
# set theme for plots
theme_set(theme_light())
theme_update(panel.grid.major = element_blank(), 
             panel.grid.minor = element_blank())
theme_update(
  strip.background = element_rect(color="gray", fill="white"), 
  strip.text = element_text(color = "gray30")
  )
```

```{r}
########
# generate simulated points
########

# generate data from distribution
set.seed(0) # reproducibility
x <- seq(0, 25, length.out = 51)
Y <- exp(x/10) + 2*sin(x/2) + rnorm(51, mean = 0, sd = 0.5)
df <- data.frame(x, Y)

# plot data and linear regression line
q1 <- ggplot(df, aes(x, Y)) +
  geom_point() +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") + 
  geom_smooth(method = "lm", formula = "y~x", 
              color = "deepskyblue3", fill = "gray70", 
              linewidth = 0.5, se = F)

# save plot
ggsave("index/figures/ch3_toy1.png", plot = q1, device = "png", 
       width = 5, height = 3)
```

```{r}
########
# kernel regression
########

# get normal distribution of weights around query points
df$Weight <- dnorm(df$x, mean = 12.5, sd = 1)

# plot points colored by their weights
p1 <- ggplot(df, aes(x, Y)) +
  geom_point(aes(color = Weight)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") + 
  geom_vline(xintercept = 12.5, linetype = "dotted") +
  theme(legend.position = "none")

# plot a curve of weights
normcurv <- data.frame(x = seq(0, 25, length.out = 250)) 
normcurv$Weight <- dnorm(normcurv$x, mean = 12.5, sd = 1)
p2 <- ggplot(normcurv, aes(x, Weight, color = Weight)) +
  geom_line() +
  scale_y_continuous(breaks = c(0, 0.2, 0.4)) +
  theme(legend.position = "none") 

# stitch plots together
q2 <- cowplot::plot_grid(p1, p2, ncol = 1, rel_heights = c(0.7, 0.3))
q2

# save plot
ggsave("index/figures/ch3_toy2.png", plot = q2, device = "png", 
       width = 5, height = 4)

# fit kernel regression with sigma = 1, bandwidth = 8/3
kmr_toy <- ksmooth(df$x, df$Y, kernel = "normal", 
                   bandwidth = 8/3, x.points = df$x)
df <- df |> 
  left_join(as.data.frame(kmr_toy), by = "x") |> 
  rename(Yhat = y)

# plot kernel regression estimation
q3 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhat), color = "deepskyblue3") 
q3

# save plot
ggsave("index/figures/ch3_toy3.png", plot = q3, device = "png", 
       width = 5, height = 3)

# fit kernel regression with sigma = 5, bandwidth = 40/3
kmr_toy_5 <- ksmooth(df$x, df$Y, kernel = "normal", 
                     bandwidth = 40/3, x.points = df$x)

# fit kernel regression with sigma = 0.1, bandwith = 8/30
kmr_toy_1 <- ksmooth(df$x, df$Y, kernel = "normal", 
                     bandwidth = 8/30, x.points = df$x)

# re-join data
dfrho <- df |> 
  left_join(as.data.frame(kmr_toy_5), by = "x") |> 
  rename("rho = 50" = y) |> 
  left_join(as.data.frame(kmr_toy_1), by = "x") |> 
  rename("rho = 0.02" = y) |> 
  select(-Yhat) |> 
  pivot_longer(cols = c("rho = 50", "rho = 0.02"), values_to = "Yhat")

# plot kernel regression with two values of rho
qrho <- ggplot(dfrho) +
  geom_point(aes(x, Y)) +
  geom_line(aes(x, Yhat), color = "deepskyblue3") +
  facet_wrap(~name)
qrho

# save plot
ggsave("index/figures/ch3_toyrho.png", plot = qrho, device = "png", 
       width = 7, height = 3)
```

```{r}
########
# spline regression
########

kn <- c(5, 10, 15, 20) # 4 knots of equal width

# fit linear spline regression
spline_toy_line <- lm(Y ~ bs(x, knots = kn, degree = 1), data = df)
p_line <- predict(spline_toy_line, se = T)
df$Yhats_line <- p_line$fit

q4 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhats_line), color = "deepskyblue3") +
  geom_vline(xintercept = kn, linetype = "dotted")
q4

# save plot
ggsave("index/figures/ch3_toy4.png", plot = q4, device = "png", 
       width = 5, height = 3)

# fit cubic spline regression
spline_toy_cub <- lm(Y ~ bs(x, knots = kn), data = df)
p_cub <- predict(spline_toy_cub, se = T)
df$Yhats_cub <- p_cub$fit

# plot spline regression estimation
q5 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhats_cub), color = "deepskyblue3") +
  geom_vline(xintercept = kn, linetype = "dotted")
q5

# save plot
ggsave("index/figures/ch3_toy5.png", plot = q5, device = "png", 
       width = 5, height = 3)

# fit natural spline regression
spline_toy_nat <- lm(Y ~ ns(x, knots = kn), data = df)
p_nat <- predict(spline_toy_nat, se = T)
df$Yhats_nat <- p_nat$fit

# plot spline regression estimation
q6 <- ggplot(df) +
  geom_point(aes(x, Y)) +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_line(aes(x, Yhats_nat), color = "deepskyblue3") +
  geom_vline(xintercept = c(5, 10, 15, 20), linetype = "dotted")
q6

# save plot
ggsave("index/figures/ch3_toy6.png", plot = q6, device = "png", 
       width = 5, height = 3)

# see what happens outside of the bounds
x_longer <- seq(-5, 30, length.out = 81)
y_longer_cub <- predict(spline_toy_cub, 
                        newdata = data.frame(x = x_longer))
y_longer_nat <- predict(spline_toy_nat, 
                        newdata = data.frame(x = x_longer))

df_longer <- data.frame(
  x = c(x_longer, x_longer), 
  spline = c(rep("Cubic", 81), rep("Natural", 81)), 
  Yhat = c(y_longer_cub, y_longer_nat)
)

# plot outside of bounds
qbounds <- ggplot(df_longer) + 
  geom_line(aes(x, Yhat), color = "deepskyblue3") +
  geom_function(fun = function(x) exp(x/10) + 2*sin(x/2), 
                linetype = "dashed", color = "darkorange") +
  geom_vline(xintercept = c(0, 25), linetype = "dotted") +
  facet_wrap(~spline) 
qbounds

# save plot
ggsave("index/figures/ch3_toybounds.png", plot = qbounds, 
       device = "png", width = 7, height = 3)
```

## Code for Section \@ref(sims):

The code for this section prepares the data from the MADRES study, generates simulated data, fits multiple linear regressions, BKMR, and BSR on the simulated data, and produces model output. 

### Code for Section \@ref(madres):

First, we clean the data from the MADRES study. 

```{r}
# load packages
library(tidyverse)
```

```{r}
# read in data
target <- read_csv("madres_data/1945_TARGETED_DATA.csv")
epi <- read_csv("madres_data/1945_EPI_DATA.csv")
```

```{r}
########
# clean target data
########

target_small <- target |> 
  # if below LOD, use LOD / sqrt(2)
  mutate(conc_mod = ifelse(Comment_code == 37, 
                           LOD / sqrt(2), 
                           Concentration)) |> 
  # adjust for urine specific gravity: Ac = A × [(SGmean –1)/(SG–1)]
  mutate(conc_mod = conc_mod * ((mean(target$SG)-1)/(SG-1))) |> 
  select(Project_ID, SID, PID, child_PID, Analyte_Code, conc_mod) |> 
  group_by(SID) |> 
  mutate(Project_ID = min(Project_ID)) |> 
  ungroup() |> 
  pivot_wider(names_from = Analyte_Code, values_from = conc_mod) |> 
  # howe kept As, Cd, Co, Hg, Ni, Tl, and Pb in main, Mo, Sb, and Sn in supp
  # don't have modified version of As used in their paper
  select(Project_ID, SID, PID, child_PID, 
         As, Cd, Co, Hg, Ni, Tl, Pb, Mo, Sb, Sn)

# save
write_csv(target_small, "madres_data/target_small.csv")

# only keep data from first trimester
target_first <- target_small |> 
  group_by(child_PID) |> 
  filter(Project_ID == min(Project_ID)) |> 
  ungroup()

# save
write_csv(target_first, "madres_data/target_first.csv")
```

```{r}
########
# clean epi data
########

# select relevant variables
epi_small <- epi |> 
  # make new categorical variables
  mutate(mom_site = as.factor(mom_site), 
         race = as.factor(case_when(
           t1_demo_hispanic == 0 & t1_demo_race == 2 ~ 1, #non-hisp white
           t1_demo_hispanic == 0 & t1_demo_race == 4 ~ 2, #non-hisp black
           t1_demo_hispanic == 0 ~ 3, #other, non-hispanic
           t1_demo_hispanic == 1 & t1_demo_usa == 1 ~ 4, #hispanic in US
           t1_demo_hispanic == 1 & t1_demo_usa == 0 ~ 5, #hispanic NOT in US
           .default = NA
         )), 
         smoke = as.factor(ifelse(
           t1_smoke_preg == 1 | t2_smoke_preg == 1 | t3_smoke_preg == 1 |
             t1_smoke == 1 | t2_smoke == 1 | t3_smoke == 1, 1, 0
         ))) |> 
  # replace -99 with NA
  mutate(across(where(is.numeric), ~ifelse(. == -99, NA, .)))  |> 
  dplyr::select(child_pid, mom_site, 
                age = t1_mat_age, # age, trimester 1
                bmi = t1_pre_BMI, # bmi
                race, # maternal r/e
                smoke, # ever-exposure to smoke
                gender, birthweight, GA # birthweight + gestational age
                # can't find anemia measure or AsB
  ) 

# handle NA values
epi_imp <- epi_small |> 
  # exclude birthweight (observed response)
  # exclude study site because of small categories
  select(-c(gender, birthweight, GA, mom_site)) |> 
  # na's for smoke during preg, set to 0
  mutate(smoke = as.factor(ifelse(is.na(smoke), 0, smoke))) |> 
  # impute mean for BMI
  mutate(across(where(is.numeric), 
                ~ifelse(is.na(.), mean(.,na.rm = TRUE), .))) 
```

```{r}
########
# combine epi and target data
########
comb <- epi_imp |> 
  left_join(target_first, by = c("child_pid" = "child_PID")) |> 
  relocate(child_pid, Project_ID, SID, PID, mom_site, race, smoke) 

# remove outliers
comb_small <- comb |> 
  filter(Mo >=1, Sb <= 1.4)

# save
write_csv(comb_small, "madres_data/base_data.csv")
```


### Code for Section \@ref(copula):

Next, we use copulas to simulate predictor data. We use the `copula` and `rslurm` packages in this section. This code was run on the Amherst HPC RStudio server. 

```{r}
# load packages
library(tidyverse)
library(copula)
library(rslurm)
```

```{r}
# read data back in
comb_small <- read_csv("madres_data/base_data.csv")

# log-transform target data
comb_log <- comb_small |> 
  mutate(across(10:19, log)) |> 
  # factors back to numeric
  mutate(across(where(is.factor), as.numeric))

# check spearman's rho
cor(comb_log[, 7:19], method = "spearman")
```

```{r}
########
# fit copulas
########

# create pseudo observations for continuous variables
u <- pobs(comb_log[, 7:19])

# fit checkerboard copula on smoke
prop_smoke0 <- 1 - mean(comb_log$smoke)
# jitter 0's and 1's uniformly within quantile
set.seed(0)
u_smoke <- comb_log$smoke |> 
  map_dbl(\(x) {
    ifelse(x == 0, runif(1, 0, prop_smoke0), runif(1, prop_smoke0, 1))
  })
u[, 1] <- u_smoke

# fit copulas
cfit_gaus <- fitCopula(normalCopula(dim = 13, dispstr = "un"), u)
cfit_t1 <- fitCopula(tCopula(dim = 13, dispstr = "un", 
                             df.fixed = FALSE), u)
cfit_t2 <- fitCopula(tCopula(dim = 13, dispstr = "un", 
                             df = 4, df.fixed = TRUE), u)
cfit_t3 <- fitCopula(tCopula(dim = 13, dispstr = "un", 
                             df = 10, df.fixed = TRUE), u)
cfit_gum1 <- fitCopula(gumbelCopula(4, dim = 13), u)
cfit_gum2 <- fitCopula(gumbelCopula(2, dim = 13), u)
cfit_frank1 <- fitCopula(frankCopula(4, dim = 13), u)
cfit_frank2 <- fitCopula(frankCopula(2, dim = 13), u)
cfit_clay1 <- fitCopula(claytonCopula(4, dim = 13), u)
cfit_clay2 <- fitCopula(claytonCopula(2, dim = 13), u)
cfit_joe1 <- fitCopula(joeCopula(4, dim = 13), u)
cfit_joe2 <- fitCopula(joeCopula(2, dim = 13), u)

# evaluate fit using AIC
aic_values <- sapply(list(cfit_gaus, cfit_t1, cfit_t2, cfit_t3, 
                          cfit_gum1, cfit_gum2, cfit_frank1, cfit_frank2, 
                          cfit_clay1, cfit_clay2, cfit_joe1, cfit_joe2
                          ), AIC)
names(aic_values) <- c("cfit_gaus", "cfit_t1", "cfit_t2", "cfit_t3",
                       "cfit_gum", "cfit_gum2", "cfit_frank1", "cfit_frank2", 
                       "cfit_clay1", "cfit_clay2", "cfit_joe1", "cfit_joe2")
sort(aic_values)

# evaluate fit using likelihood
aic_values <- sapply(list(cfit_gaus, cfit_t1, cfit_t2, cfit_t3, 
                          cfit_gum1, cfit_gum2, cfit_frank1, cfit_frank2, 
                          cfit_clay1, cfit_clay2, cfit_joe1, cfit_joe2
                          ), logLik)
names(lik_values) <- c("cfit_gaus", "cfit_t1", "cfit_t2", "cfit_t3",
                       "cfit_gum", "cfit_gum2", "cfit_frank1", "cfit_frank2", 
                       "cfit_clay1", "cfit_clay2", "cfit_joe1", "cfit_joe2")
sort(lik_values)

# guassian copula performs best, proceed with this
write_rds(cfit_gaus, "sim/gauscop.RDS")
```

```{r}
########
# simulate predictor data
########

# read copula back in 
cfit_gaus <- read_rds("sim/gauscop.RDS")

# extract rho 
rho <- coef(cfit_gaus)

# create function for simulation
simulate_data <- function(data, n, rho, prop_smoke, prop_race) {
  #' data = original observed data
  #' n = sample size
  #' rho = rho values from normal copula
  #' prop_smoke = proportion smoke from observed dataset
  #' prop_race = table with race/eth values
  
  # simulate pseudo-observations from copula
  samp <- rCopula(n, normalCopula(rho, dim = ncol(data), dispstr = "un"))
  
  # transform pseudo-observations to observed marginal distributions
  sampt <- 1:ncol(data) |> 
    purrr::map_dfc(
      \(x) {
        if(names(data)[x] == "smoke") {
          # use observed probability threshold for smoke
          df <- data.frame(ifelse(samp[,x] < prop_smoke, 0, 1), 
                           row.names = NULL)
        } else {
          # use empirical marginal CDF's for continuous
          df <- data.frame(quantile(data[[x]], probs = samp[,x]), 
                           row.names = NULL)
        }
        names(df) <- names(data)[x]
        return(df)
      }
    ) |> 
    # randomly sample race
    mutate(race = sample(x = names(prop_race), prob = prop_race,
                         size = n, replace = T)) |> 
    relocate(race)
  return(sampt)
}

# create function to run size 252 samples on hpc
run_sim1 <- function() {
  set.seed(0)
  out <- 1:2100 |> 
    purrr::map(\(x) {
      mutate(simulate_data(comb_log_clip, n = nrow(comb_log_clip), rho = rho, 
                           prop_smoke = 1-mean(comb_log_clip$smoke), 
                           prop_race = table(comb_log$race)), 
             race = as.numeric(race), 
             sim = x) 
    })
  return(out)
}

# send job to hpc for size 252 samples
sjob1 <- slurm_call(run_sim1, 
                    global_objects = c('comb_log', 'comb_log_clip', 
                                       'rho', 'simulate_data'),
                    jobname = 'sim_data1')

# get output
out1 <- get_slurm_out(sjob1)
write_rds(out1, "sim/sim_preds_sm.RDS")

# create function to run size 1000 samples on hpc
run_sim2 <- function() {
  set.seed(1)
  out <- 1:2100 |> 
    purrr::map(\(x) {
      mutate(simulate_data(comb_log_clip, n = 1000, rho = rho, 
                           prop_smoke = 1-mean(comb_log_clip$smoke), 
                           prop_race = table(comb_log$race)), 
             race = as.numeric(race), 
             sim = x)
    })
  return(out)
}

# send job to hpc for size 1000 samples
sjob2 <- slurm_call(run_sim2, 
                    global_objects = c('comb_log', 'comb_log_clip', 
                                       'rho', 'simulate_data'),
                    jobname = 'sim_data2')

# get output
out2 <- get_slurm_out(sjob2)
write_rds(out2, "sim/sim_preds_lg.RDS")
```

Here, we visualize the observed and simulated predictor data. 

```{r}
# load packages
library(tidyverse)
library(latex2exp) # for printing latex on ggplot

# set theme for plots
theme_set(theme_light())
theme_update(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
theme_update(
  strip.background = element_rect(color="gray", fill="white"), 
  strip.text = element_text(color = "gray30")
)
```

```{r}
########
# observed data
########

# read target data back in
target_first <- read_csv("madres_data/target_first.csv")

# create spearman's correlation matrix
cor_mat <- cor(target_first[, 5:14], method = "spearman")
cor_mat[lower.tri(cor_mat)] <- NA

# reshape correlation matrix to longer format
melt_cor <- reshape2::melt(cor_mat) |> 
  mutate(label = ifelse(value == 1, NA, round(value, 2))) |> 
  na.omit()

# create correlation heatmap
cor_orig <- melt_cor |> 
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = label), size = 3.5) +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  coord_fixed() +
  labs(x = NULL, y = NULL, fill = TeX(r"( Spearman's $\rho$ )")) +
  theme(
    panel.grid.major.x = element_line(color = "grey85",
                                      linewidth = 0.25,
                                      linetype = 2), 
    panel.border = element_blank(),
    legend.justification = c(1, 0),
    legend.position = c(0.9, 0.1),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))
cor_orig

ggsave("index/figures/ch4_corr.png", width = 5, height = 5)
```


```{r}
# read target and epi data back in
comb_small <- read_csv("madres_data/base_data.csv")

# log-transform target data
comb_log <- comb_small |> 
  mutate(across(10:19, log)) |> 
  # factors back to numeric
  mutate(across(where(is.factor), as.numeric))

# look at densities of exposures before log-transform
univ1 <- comb_small |> 
  select(10:19) |> 
  pivot_longer(cols = 1:10) |> 
  mutate(name = factor(name, levels = names(comb_small)[10:19])) |> 
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(~name, scales = "free", nrow = 2) +
  labs(x = "Concentration (ng/mL)")
# look at densities of exposures after log-transform
univ2 <- comb_log |> 
  select(10:19) |> 
  pivot_longer(cols = 1:10) |> 
  mutate(name = factor(name, levels = names(comb_small)[10:19])) |> 
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(~name, scales = "free", nrow = 2) +
  labs(x = "Natural log concentration (log(ng/mL))")

# plot in grid and save
cowplot::plot_grid(univ1, univ2, labels = "auto", nrow = 2)
ggsave("index/figures/ch4_univlog.png", width = 7.5, height = 5)
```


```{r}
# density plot of continuous covariates
cov_cont <- comb_log |> 
  select(age, bmi) |> 
  pivot_longer(cols = 1:2) |> 
  ggplot(aes(x = value)) +
  geom_density() + 
  facet_wrap(~name, scales = "free", ncol = 1) 

# create new dataset for dist. of categorical covariates
df_forcovcat <- comb_log |> 
  select(smoke, race) |> 
  mutate(smoke = ifelse(smoke == 0, "Never-exposed", "Ever-exposed"), 
         race = case_when(
           race == 1 ~ "Non-Hisp. white", 
           race == 2 ~ "Non-Hisp. black", 
           race == 3 ~ "Non-Hisp. other", 
           race == 4 ~ "Hispanic born\nin US", 
           race == 5 ~ "Hispanic born\noutside US"
         )) |> 
  pivot_longer(cols = 1:2) |> 
  mutate(value = factor(
    value, levels = rev(c("Never-exposed", "Ever-exposed",
                      "Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
                      "Hispanic born\nin US", "Hispanic born\noutside US"))
  )) 

# bar plot of categorical covariates
cov_cat <- df_forcovcat |> 
  ggplot(aes(x = value)) +
  geom_bar(stat = "count", fill = "gray") +
  geom_text(aes(label = after_stat(count)), stat = "count", 
             size = 3, hjust = 1, nudge_y = -2) +
  facet_wrap(~name, scales = "free", ncol = 1) +
  coord_flip() +
  labs(x = NULL)

# plot and save
cowplot::plot_grid(cov_cont, cov_cat, labels = "auto", nrow = 1, 
                   rel_widths = c(0.4, 0.6))
ggsave("index/figures/ch4_covdist.png", width = 6, height = 4)
```

```{r}
#look at association between race and chemicals
name_order <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")
comb_log |> 
  select(c(6, 10:19)) |> 
  pivot_longer(cols = 2:11, names_to = "key", values_to = "value") |> 
  mutate(key = factor(key, levels = name_order)) |> 
  mutate(race = as.factor(race)) |> 
  ggplot(aes(x = race, y = value, color = race)) +
  geom_boxplot() +
  scale_color_discrete(
    name = "Race by ethnicity\nand birth place", 
    labels = c("Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
               "Hispanic born\nin US", "Hispanic born\noutside US")) + 
  theme(legend.spacing.y = unit(0.25, 'cm')) +
  guides(color = guide_legend(byrow = TRUE)) +
  labs(x = "Race, coded", y = "Log concentration") +
  facet_wrap(~key, scales = "free_y")

# save
ggsave("index/figures/ch4_race_exp.png", width = 7, height = 3.5)
```


```{r}
########
# look at simulated data, smaller size
########

# read smaller size simulation back in
out1 <- read_rds("sim/sim_preds_sm.RDS")
comb_sim1 <- bind_rows(out1)

# density plots for exposures
name_order <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")
comb_sim1 |> 
  mutate(sim = as.factor(sim)) |> 
  select(5:15) |> 
  pivot_longer(cols = 1:10) |>
  mutate(name = factor(name, levels = name_order)) |> 
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  # reference density from observed data
  geom_density(
    data = comb_log |> select(10:19) |> pivot_longer(cols = 1:10) |> 
      mutate(name = factor(name, levels = name_order)),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free")
# save
ggsave("index/figures/ch4_univ_exp_sim.png", width = 6, height = 4)
```

```{r}
# density plot for continuous covariates
cov_sim_p <- comb_sim1 |> 
  mutate(sim = as.factor(sim)) |> 
  select(age, bmi, sim) |> 
  pivot_longer(cols = 1:2) |>
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  geom_density(
    data = comb_log |> select(age, bmi) |> pivot_longer(cols = 1:2),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free", ncol = 1)

# bar + violin plot for categorical covariates
cov_sim_q <- comb_sim1 |> 
  mutate(sim = as.factor(sim)) |> 
  select(sim, smoke, race) |> 
  mutate(smoke = ifelse(smoke == 0, "Never-exposed", "Ever-exposed"), 
         race = case_when(
           race == 1 ~ "Non-Hisp. white", 
           race == 2 ~ "Non-Hisp. black", 
           race == 3 ~ "Non-Hisp. other", 
           race == 4 ~ "Hispanic born\nin US", 
           race == 5 ~ "Hispanic born\noutside US"
         )) |> 
  pivot_longer(cols = 2:3) |> 
  group_by(sim, name, value) |> 
  summarize(count = n()) |> 
  mutate(value = factor(
    value, levels = rev(c("Never-exposed", "Ever-exposed",
                          "Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
                          "Hispanic born\nin US", "Hispanic born\noutside US"))
  )) |> 
  ggplot(aes(x = value, y = count)) +
  geom_bar(data = df_forcovcat, aes(x = value), inherit.aes = FALSE,
           stat = "count", fill = "skyblue") +
  geom_violin(color = "gray30", fill = "gray", alpha = 0.25) + 
  facet_wrap(~name, scales = "free", ncol = 1) +
  coord_flip() +
  labs(x = NULL)

# plot in grid and save
cowplot::plot_grid(cov_sim_p, cov_sim_q, labels = "auto", nrow = 1, 
                   rel_widths = c(0.4, 0.6))
  
ggsave("index/figures/ch4_univ_cov_sim.png", width = 6, height = 4)
```

```{r}
# look at correlation structure

# extract correlation structure from simulated data
cors <- out1 |> 
  purrr::map_df(\(x) {
    cor_mat <- cor(x[, 5:14], method = "spearman")
    cor_mat[lower.tri(cor_mat)] <- NA
    melt_cor <- reshape2::melt(cor_mat) |> 
      mutate(value = ifelse(value == 1, NA, value)) |> 
      na.omit() |> 
      mutate(sim = x$sim[1])
    return(melt_cor)
  })

# # create function for breaks on density plot grid
# newbreaks <- function(lims) {
#   range <- diff(lims)
#   return(c(lims[1] + range/5, mean(lims), lims[2] - range/5))
# }
# 
# # density plot grid of spearman's correlation in simulated data
# cors_dens <- cors |> 
#   group_by(Var1, Var2) |> 
#   mutate(mean = mean(value)) |> 
#   ungroup() |> 
#   ggplot(aes(x = value, fill = mean)) +
#   geom_density() + 
#   scale_x_continuous(breaks = newbreaks, 
#                      labels = ~round(.x, 2)) +
#   scale_y_continuous(position = "right") +
#   scale_fill_gradient2(
#     limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
#     low = "deepskyblue3", mid = "white", high = "darkorange", 
#     na.value = NA) +
#   ggh4x::facet_grid2(fct_rev(Var2) ~ Var1, scales = "free", independent = "x", 
#                      render_empty = FALSE, switch = "both") +
#   labs(x = TeX(r"( Spearman's $\rho$ )")) +
#   theme(strip.placement = "outside", 
#         strip.text.y.left = element_text(angle = 0), 
#         legend.justification = c(1, 0),
#         legend.position = c(0.9, 0.1),
#         legend.direction = "horizontal") +
#   guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
#                                title.position = "top", title.hjust = 0.5))
# 
# # plot and save
# cors_dens
# ggsave("index/figures/ch4_corr_sim.png", width = 10, height = 7)

# correlation heatmap of average correlation in simulated data
cor_sim <- cors |> 
  group_by(Var1, Var2) |> 
  summarize(value = mean(value)) |> 
  mutate(label = round(value, 2)) |> 
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = label), size = 3.5) +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  coord_fixed() +
  labs(x = NULL, y = NULL, fill = TeX(r"( Mean Spearman's $\rho$ )")) +
  theme(
    panel.grid.major.x = element_line(color = "grey85",
                                      linewidth = 0.25,
                                      linetype = 2), 
    panel.border = element_blank(),
    legend.justification = c(1, 0),
    legend.position = c(0.9, 0.1),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))

# plot and save
cor_sim
ggsave("index/figures/ch4_corr_avg_sim.png", width = 5, height = 5)

# put original and simulated correlation heatmaps together
top_row <- cowplot::plot_grid(cor_orig, cor_sim, labels = "auto", label_size = 16, 
                   nrow = 1, scale = 0.95)
top_row
ggsave("index/figures/ch4_corr_sim+orig.png", width = 10, height = 5)

# # put original, simulated, and density plots of correlation together
# cowplot::plot_grid(top_row, cors_dens, labels = c("", "c"), label_size = 16, 
#                    nrow = 2, rel_heights = c(5, 7), scale = c(1, 0.95))
# ggsave("index/figures/ch4_corr_simorigdens.png", width = 10, height = 12)
```




### Code for Section \@ref(simresp):

Next, we simulate the response data. We use the `rslurm` package in this section. This code was run on the Amherst HPC RStudio server. 

```{r}
# load packages
library(tidyverse)
library(rslurm)
```


```{r}
##############
# create functions for various response variables
##############

# base case, no interactions
base_case <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, mult, small
am1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.35*Hg*Ni + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, mult, large
am2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.7*Hg*Ni + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, poly, small
ap1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.13*Hg*((Ni-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxNi, poly, large
ap2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.26*Hg*((Ni-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, mult, small
bm1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.35*Cd*As + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, mult, large
bm2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.7*Cd*As + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, poly, small
bp1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.125*Cd*((As-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# CdxAs, poly, large
bp2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.25*Cd*((As-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, mult, small
cm1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.3*Hg*Co + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, mult, large
cm2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.6*Hg*Co + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, poly, small
cp1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.15*Hg*((Co-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# HgxCo, poly, large
cp2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.3*Hg*((Co-1)^2) +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, multi, small
dm1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.3*Hg*Ni*Tl + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, multi, large
dm2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.6*Hg*Ni*Tl + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, poly, small
dp1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.09*Hg*((Ni-1)^2)*Tl +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# three-way, poly, large
dp2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           0.18*Hg*((Ni-1)^2)*Tl +
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}
```

```{r}
#############
# create response variables for exposure-exposure interxn
#############

# read output back in, size 252
out1 <- read_rds("sim/sim_preds_sm.RDS")

# create function for responses at size 252
run_resp1 <- function() {
  set.seed(0)
  out1_resp1 <- out1 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1] 
      x <- x |> 
        # scale log-transformed exposures and covariates
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 100 ~ base_case(x), 
        no <= 200 ~ am1(x), 
        no <= 300 ~ am2(x), 
        no <= 400 ~ ap1(x), 
        no <= 500 ~ ap2(x), 
        no <= 600 ~ bm1(x), 
        no <= 700 ~ bm2(x), 
        no <= 800 ~ bp1(x), 
        no <= 900 ~ bp2(x), 
        no <= 1000 ~ cm1(x), 
        no <= 1100 ~ cm2(x), 
        no <= 1200 ~ cp1(x), 
        no <= 1300 ~ cp2(x), 
        no <= 1400 ~ dm1(x), 
        no <= 1500 ~ dm2(x), 
        no <= 1600 ~ dp1(x), 
        no <= 1700 ~ dp2(x), 
        .default = x #note 1701 - 2100 is for cov-exp interxn
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("_base", 100), 
      rep("am1", 100), 
      rep("am2", 100), 
      rep("ap1", 100), 
      rep("ap2", 100), 
      rep("bm1", 100), 
      rep("bm2", 100), 
      rep("bp1", 100), 
      rep("bp2", 100), 
      rep("cm1", 100), 
      rep("cm2", 100), 
      rep("cp1", 100), 
      rep("cp2", 100), 
      rep("dm1", 100), 
      rep("dm2", 100), 
      rep("dp1", 100), 
      rep("dp2", 100), 
      rep("unset", 400)
    )) 
  return(out1_resp1)
}

# run to hpc
runrespsm <- slurm_call(
  run_resp1, 
  global_objects = c('out1', 'base_case', 
                     'am1', 'am2', 'ap1', 'ap2', 
                     'bm1', 'bm2', 'bp1', 'bp2', 
                     'cm1', 'cm2', 'cp1', 'cp2', 
                     'dm1', 'dm2', 'dp1', 'dp2'),
  jobname = 'sim_resp1')

# get output
out1_resp1 <- get_slurm_out(runrespsm)
# only save for exp-exp interxns
out1_resp1 <- out1_resp1[1:1700]
write_rds(out1_resp1, "sim/sim_resp_sm_a.RDS")

# read output back in, size 1000
out2 <- read_rds("sim/sim_preds_lg.RDS")

# create function for response at size 1000
run_resp2 <- function() {
  set.seed(0)
  out2_resp1 <- out2 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1]
      x <- x |> 
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 100 ~ base_case(x), 
        no <= 200 ~ am1(x), 
        no <= 300 ~ am2(x), 
        no <= 400 ~ ap1(x), 
        no <= 500 ~ ap2(x), 
        no <= 600 ~ bm1(x), 
        no <= 700 ~ bm2(x), 
        no <= 800 ~ bp1(x), 
        no <= 900 ~ bp2(x), 
        no <= 1000 ~ cm1(x), 
        no <= 1100 ~ cm2(x), 
        no <= 1200 ~ cp1(x), 
        no <= 1300 ~ cp2(x), 
        no <= 1400 ~ dm1(x), 
        no <= 1500 ~ dm2(x), 
        no <= 1600 ~ dp1(x), 
        no <= 1700 ~ dp2(x), 
        .default = x #note 1701 - 2100 is for cov-exp interxn
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("_base", 100), 
      rep("am1", 100), 
      rep("am2", 100), 
      rep("ap1", 100), 
      rep("ap2", 100), 
      rep("bm1", 100), 
      rep("bm2", 100), 
      rep("bp1", 100), 
      rep("bp2", 100), 
      rep("cm1", 100), 
      rep("cm2", 100), 
      rep("cp1", 100), 
      rep("cp2", 100), 
      rep("dm1", 100), 
      rep("dm2", 100), 
      rep("dp1", 100), 
      rep("dp2", 100), 
      rep("unset", 400)
    ))
  return(out2_resp1)
}

# send to HPC
runresplg <- slurm_call(
  run_resp2, 
  global_objects = c('out2', 'base_case', 
                     'am1', 'am2', 'ap1', 'ap2', 
                     'bm1', 'bm2', 'bp1', 'bp2', 
                     'cm1', 'cm2', 'cp1', 'cp2', 
                     'dm1', 'dm2', 'dp1', 'dp2'),
  jobname = 'sim_resp2')

# get output
out2_resp1 <- get_slurm_out(runresplg)
# only save output for exp-exp interxns for now
out2_resp1 <- out2_resp1[1:1700]
write_rds(out2_resp1, "sim/sim_resp_lg_a.RDS")
```


```{r}
#############
# create response variables for exposure-covariate interxn
#############

# functions for creating response
# interxn in smaller group, smaller effect size
em1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5 + 0.5*Hg, # 1.5x in group 2
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# interxn in smaller group, larger effect size
em2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5 + Hg, # double in group 2
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5) +
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# interxn in larger group, smaller effect size
ep1 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5 + 0.5*Hg) + # 1.5x in group 5
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# interxn in larger group, larger effect size
ep2 <- function(df) {
  mutate(df, y = 
           Hg + 3/(1+exp(-4*Ni)) - (Sb^2) + 0.5*Sb + 1.5/(1+exp(-4*Sn)) + 
           age + 0.5*bmi + 
           case_when(race == 1 ~ 1, 
                     race == 2 ~ 1.5, 
                     race == 3 ~ 1, 
                     race == 4 ~ 1, 
                     race == 5 ~ 1.5 + Hg) + # double in group 5
           ifelse(smoke == 1, -1, 0.5) +
           rnorm(nrow(df), 0, 5))
}

# read output back in, size 252
out1 <- read_rds("sim/sim_preds_sm.RDS")

# create function to simulate response for smaller size
run_resp1_re <- function() {
  set.seed(0)
  out1_resp1 <- out1 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1] 
      x <- x |> 
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 1700 ~ x, #note 1 - 1700 are chemxchem
        no <= 1800 ~ em1(x), 
        no <= 1900 ~ em2(x), 
        no <= 2000 ~ ep1(x), 
        no <= 2100 ~ ep2(x), 
        .default = x 
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("unset", 1700), 
      rep("em1", 100), 
      rep("em2", 100), 
      rep("ep1", 100), 
      rep("ep2", 100)
    )) 
  return(out1_resp1)
}

# send to HPC
runrespsm_re <- slurm_call(
  run_resp1_re, 
  global_objects = c('out1', 
                     'em1', 'em2', 'ep1', 'ep2'),
  jobname = 'sim_resp1_re')

# get output
out1_resp1_re <- get_slurm_out(runrespsm_re)
out1_resp1_re <- out1_resp1_re[1701:2100]
write_rds(out1_resp1_re, "sim/sim_resp_sm_re.RDS")

# read output back in, size 1000
out2 <- read_rds("sim/sim_preds_lg.RDS")

# create function to simulate response for larger size
run_resp2_re <- function() {
  set.seed(0)
  out2_resp1 <- out2 |> 
    purrr::map(\(x) {
      # get dataset number 
      no <- x$sim[1] 
      x <- x |> 
        mutate(across(age:Sn, ~c(scale(.)))) 
      df <- case_when(
        no <= 1700 ~ x, #note 1 - 1700 are chemxchem
        no <= 1800 ~ em1(x), 
        no <= 1900 ~ em2(x), 
        no <= 2000 ~ ep1(x), 
        no <= 2100 ~ ep2(x), 
        .default = x 
      ) 
    }) |> 
    purrr::set_names(nm = c(
      rep("unset", 1700), 
      rep("em1", 100), 
      rep("em2", 100), 
      rep("ep1", 100), 
      rep("ep2", 100)
    )) 
  return(out2_resp1)
}

# send to HPC
runresplg_re <- slurm_call(
  run_resp2_re, 
  global_objects = c('out2', 
                     'em1', 'em2', 'ep1', 'ep2'),
  jobname = 'sim_resp2_re')

# get output
out2_resp1_re <- get_slurm_out(runresplg_re)
out2_resp1_re <- out2_resp1_re[1701:2100]
write_rds(out2_resp1_re, "sim/sim_resp_lg_re.RDS")
```

### Code for Section \@ref(models):

Here, we fit the models to our simulated data. We use the `rslurm`, `bkmr`, and `NLinteraction` packages in this section. This code was run on the Amherst HPC RStudio server. 

```{r}
# load packages 
library(tidyverse)
library(bkmr)
library(NLinteraction)
```

First, we fit the naive and oracle MLRs.

```{r}
#########
# naive and oracle MLRs 
#########

### smaller size

# read in simulated data
out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

run_mlr_sm <- function() {
  # initialize vectors
  mlrs <- vector(mode='list', length = 1700)
  names(mlrs) <- names(out1_resp1)
  mlrtimes <- vector(mode = 'list', length = 1700)
  names(mlrtimes) <- names(out1_resp1)
  
  oracles <- vector(mode='list', length = 1700)
  names(oracles) <- names(out1_resp1)
  oracletimes <- vector(mode = 'list', length = 1700)
  names(oracletimes) <- names(out1_resp1)
  
  for(i in 1:1700) {
    df <- out1_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    start.time <- Sys.time()
    mlrs[[i]] <- lm(y ~ ., data = df)
    end.time <- Sys.time()
    mlrtimes[[i]] <- end.time - start.time
    
    if(i <= 100) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 300) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg*Ni + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 500) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 700) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Cd*As + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 900) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Cd*((As-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1100) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Ni*Co + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1300) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Ni*((Co-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1500) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg:Ni:Tl + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    } else if (i <= 1700) {
      start.time <- Sys.time()
      oracles[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)*Tl) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimes[[i]] <- end.time - start.time
    }
  }
  return(list(mlrs, mlrtimes, oracles, oracletimes))
}

# send to hpc
sjob5 <- slurm_call(
  run_mlr_sm, 
  global_objects = c('out1_resp1'),
  jobname = 'mlr_sm')

# get output
mlr_sm <- get_slurm_out(sjob5)
mlr_mods <- mlr_sm[[1]]
mlr_times <- mlr_sm[[2]]
oracle_mods <- mlr_sm[[3]]
oracle_times <- mlr_sm[[4]]
write_rds(mlr_mods, "sim/mlr_mods_sm.RDS")
write_rds(mlr_times, "sim/mlr_mods_sm_times.RDS")
write_rds(oracle_mods, "sim/oracle_mods_sm.RDS")
write_rds(oracle_times, "sim/oracle_mods_sm_times.RDS")

### larger sample size

# read in simulated data
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_mlr_lg <- function() {
  # initialize vectors
  mlrl <- vector(mode='list', length = 1700)
  names(mlrl) <- names(out2_resp1)
  mlrtimel <- vector(mode = 'list', length = 1700)
  names(mlrtimel) <- names(out2_resp1)
  
  oraclel <- vector(mode='list', length = 1700)
  names(oraclel) <- names(out2_resp1)
  oracletimel <- vector(mode = 'list', length = 1700)
  names(oracletimel) <- names(out2_resp1)
  
  for(i in 1:1700) {
    df <- out2_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    start.time <- Sys.time()
    mlrl[[i]] <- lm(y ~ ., data = df)
    end.time <- Sys.time()
    mlrtimel[[i]] <- end.time - start.time
    
    if(i <= 100) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 300) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg*Ni + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 500) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 700) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Cd*As + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 900) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Cd*((As-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1100) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Ni*Co + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1300) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Ni*((Co-1)^2)) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1500) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           Hg:Ni:Tl + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    } else if (i <= 1700) {
      start.time <- Sys.time()
      oraclel[[i]] <- lm(y ~ Hg + Sb +
                           I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                           I(Hg*((Ni-1)^2)*Tl) + 
                           age + bmi + race + smoke, data = df)
      end.time <- Sys.time()
      oracletimel[[i]] <- end.time - start.time
    }
  }
  return(list(mlrl, mlrtimel, oraclel, oracletimel))
}

# send to hpc
sjob6 <- slurm_call(
  run_mlr_lg, 
  global_objects = c('out2_resp1'),
  jobname = 'mlr_lg')

# get output
mlr_lg <- get_slurm_out(sjob6)
mlr_modl <- mlr_lg[[1]]
mlr_timel <- mlr_lg[[2]]
oracle_modl <- mlr_lg[[3]]
oracle_timel <- mlr_lg[[4]]
write_rds(mlr_modl, "sim/mlr_mods_lg.RDS")
write_rds(mlr_timel, "sim/mlr_mods_lg_times.RDS")
write_rds(oracle_modl, "sim/oracle_mods_lg.RDS")
write_rds(oracle_timel, "sim/oracle_mods_lg_times.RDS")
```


Next, we fit BKMR and BSR models with the base case and with interactions between chemicals. 

```{r}
#########
# run bkmr
#########

### smaller sample size

out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

run_bkmr_sm <- function(vector) {
  # initiate vector of times
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # for each simulated dataset...
  for(i in vector) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out1_resp1[[i]]
    Z <- df |> 
      select(As:Sn)
    X <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi)
    y <- df$y
    
    # fit model and save time
    set.seed(0)
    start.time <- Sys.time()
    mod <- kmbayes(y = y, Z = Z, X = X, 
                          iter = 50000, verbose = FALSE, varsel = TRUE)
    end.time <- Sys.time()
    bkmr_times[[i]] <- end.time - start.time
    
    # save model and remove from memory
    write_rds(mod, file = paste0("mods/bkmr_sm_", names(out1_resp1)[i], "_", i, ".RDS"))
    write_rds(bkmr_times[[i]], file = 
                paste0("times/bkmr_sm_", names(out1_resp1)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # save times
  write_rds(bkmr_times, file = "bkmr_sm_times.RDS")
}

# example of call to HPC for first 100 simulated datasets
bksmjob01 <- slurm_call(
  run_bkmr_sm, params = list(vector = 1:100),
  global_objects = c('out1_resp1'),
  jobname = 'bkmr_sm01',
  slurm_options = list(mem = '8G'))
  # repeat up until dataset 1700
```

```{r}
### larger sample size
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_bkmr_lg <- function(vector) {
  # initiate vector of times
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes this code would stop prematurely...
  # so this chunk finds the index of the last model that was run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".*_(\\d+)\\.RDS", "\\1", list_files))
  print(nums)
  if(length(nums) == 0) {
    final <- 0; starting <- min(vector)
  } else {
    final <- max(nums); starting <- final + 1
  }
  # keep note of when the loop was stopped and re-started
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  # for each simulated dataset...
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out2_resp1[[i]]
    Z <- df |> 
      select(As:Sn)
    X <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi)
    y <- df$y
    knots <- fields::cover.design(Z, nd = 100)$design
    
    # fit model and save time
    set.seed(0)
    start.time <- Sys.time()
    mod <- kmbayes(y = y, Z = Z, X = X, knots = knots,
                   iter = 50000, verbose = FALSE, varsel = TRUE)
    end.time <- Sys.time()
    bkmr_times[[i]] <- end.time - start.time
    
    # save model and remove from memory
    write_rds(mod, file = paste0("mods/bkmr_lg_", names(out2_resp1)[i], "_", i, ".RDS"))
    write_rds(bkmr_times[[i]], file = 
                paste0("times/bkmr_lg_", names(out2_resp1)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # save times
  write_rds(bkmr_times, file = "bkmr_lg_times.RDS")
}

# example of call to HPC for first 100 simulated datasets
bklgjob01 <- slurm_call(
  run_bkmr_lg, params = list(vector = 1:100),
  global_objects = c('out2_resp1'),
  jobname = 'bkmr_lg01',
  slurm_options = list(mem = '8G'))
  # repeat up until dataset 1700
```

```{r}
########
# run bsr
########

### smaller sample size

out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")

run_bsr_sm <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes this code would stop prematurely...
  # so this chunk finds the index of the last model that was run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0; starting <- min(vector)
  } else {
    final <- max(nums); starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  # for each simulated dataset...
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out1_resp1[[i]]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # fit model for d = {1, 2, 3, 4, 5} and save time
    list_times <- vector(mode = "list", length = 2)
    
    set.seed(0)
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    print(paste0("-------- chose ", ind, " -----------"))
    
    # fit with selected d from waic
    start.time <- Sys.time()
    mod <- NLint(Y = Y, X = X, C = C, 
                 nIter = 50000, nBurn = 25000, ns = ind)
    end.time <- Sys.time()
    list_times[[2]] <- end.time - start.time
    
    bsr_times[[i]] <- list_times
    
    # save model and remove from memory
    write_rds(mod, file = 
                paste0("mods/bsr_sm_", names(out1_resp1)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                 paste0("times/bsr_sm_", names(out1_resp1)[i], "_", i, 
                        "df", ind, ".RDS"))
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  write_rds(bsr_times, file = "bsr_smf_times.RDS")
  return(bsr_times)
}

# example of call to HPC for first 100 simulated datasets
rjob01 <- slurm_call(
  run_bsr_sm, params = list(vector = 1:100),
  global_objects = c('out1_resp1'),
  jobname = 'bsr_sm01',
  slurm_options = list(mem = '8G'))
  # repeat up until dataset 1700
```

```{r}
### larger sample size

out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_bsr_lg <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes this code would stop prematurely...
  # so this chunk finds the index of the last model that was run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0; starting <- min(vector)
  } else {
    final <- max(nums); starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df <- out2_resp1[[i]]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |>
      bind_cols(
        data.frame(model.matrix(~ race-1, data = 
                                  mutate(df, race = as.factor(race))))
      ) |> 
      select(race2:race5, smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # fit model for d = {1, 2, 3, 4, 5} and save time
    list_times <- vector(mode = "list", length = 2)
    
    set.seed(0)
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    print(paste0("-------- chose ", ind, " -----------"))
    
    start.time <- Sys.time()
    mod <- NLint(Y = Y, X = X, C = C, 
                 nIter = 50000, nBurn = 25000, ns = ind)
    end.time <- Sys.time()
    list_times[[2]] <- end.time - start.time
    
    bsr_times[[i]] <- list_times
    
    # save model and remove from memory
    write_rds(mod, file = 
                paste0("mods/bsr_lgf_", names(out2_resp1)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bsr_lgf_", names(out2_resp1)[i], "_", i, 
                       "df", ind, ".RDS"))
    
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  write_rds(bsr_times, file = "bsr_lgf_times.RDS")
  # return(bsr_times)
}

# example of call to HPC for first 100 simulated datasets
qjob01 <- slurm_call(
  run_bsr_lg, params = list(vector = 1:100),
  global_objects = c('out2_resp1'),
  jobname = 'bsr_lg01',
  slurm_options = list(mem = '8G'))
  # repeat up until dataset 1700
```

Next, we fit stratified models with an interaction between the categorical race variable and a chemical. 

```{r}
##########
# stratified bkmr, smaller size
##########

out1_resp1_re <- read_rds("sim/sim_resp_sm_re.RDS")

run_bkmr_sm_re <- function(vector) {
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  for(i in vector) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out1_resp1_re[[i]]
    
    # for each race level, run bmkr
    list_times <- vector(mod = "list", length = 6)
    list_mods <- vector(mod = "list", length = 6)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      Z <- df |> 
        select(As:Sn)
      X <- df |>
        select(smoke:bmi)
      y <- df$y
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- tryCatch({
        kmbayes(y = y, Z = Z, X = X, 
                iter = 50000, verbose = FALSE, varsel = TRUE)
      }, error = function(e) {
        NA
      })
      end.time <- Sys.time()
      list_times[[i]] <- end.time - start.time
      list_mods[[i]] <- mod
    }
    
    # combine 1-3 r/e
    df <- df_full[df_full$race %in% c(1, 2, 3), ]
    Z <- df |> 
      select(As:Sn)
    X <- df |>
      select(smoke:bmi)
    y <- df$y
    
    # fit model and save time
    start.time <- Sys.time()
    mod <- tryCatch({
      kmbayes(y = y, Z = Z, X = X, 
              iter = 50000, verbose = FALSE, varsel = TRUE)
    }, error = function(e) {
      NA
    })
    end.time <- Sys.time()
    list_times[[6]] <- end.time - start.time
    list_mods[[6]] <- mod
    
    
    bkmr_times[[i]] <- list_times
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bkmr_sm_", names(out1_resp1_re)[i], "_", i, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bkmr_smf_", names(out1_resp1_re)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # write_rds(bkmr_times, file = "bkmr_sm_times.RDS")
  return(bkmr_times)
}

# send to hpc
ujob01 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 1:100),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre01',
  slurm_options = list(mem = '8G'))

ujob02 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 101:200),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre02',
  slurm_options = list(mem = '8G'))

ujob03 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 201:300),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre03',
  slurm_options = list(mem = '8G'))

ujob04 <- slurm_call(
  run_bkmr_sm_re, params = list(vector = 301:400),
  global_objects = c('out1_resp1_re'),
  jobname = 'ksmre04',
  slurm_options = list(mem = '8G'))
```

```{r}
##########
# stratified bkmr, larger size
##########

out2_resp1_re <- read_rds("sim/sim_resp_lg_re.RDS")

run_bkmr_lg_re <- function(vector) {
  bkmr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  for(i in vector) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out2_resp1_re[[i]]
    
    # for each race level, run bmkr
    list_times <- vector(mod = "list", length = 5)
    list_mods <- vector(mod = "list", length = 5)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      Z <- df |> 
        select(As:Sn)
      X <- df |>
        select(smoke:bmi)
      y <- df$y
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- kmbayes(y = y, Z = Z, X = X, 
                     iter = 50000, verbose = FALSE, varsel = TRUE)
      end.time <- Sys.time()
      list_times[[i]] <- end.time - start.time
      list_mods[[i]] <- mod
    }
    
    bkmr_times[[i]] <- list_times
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bkmr_lg_", names(out2_resp1_re)[i], "_", i, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bkmr_lgf_", names(out2_resp1_re)[i], "_", i, ".RDS"))
    rm(mod)
  }
  # write_rds(bkmr_times, file = "bkmr_lg_times_re.RDS")
  return(bkmr_times)
}

# send to hpc
tjob01 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 1:100),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre01',
  slurm_options = list(mem = '8G'))

tjob02 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 101:200),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre02',
  slurm_options = list(mem = '8G'))

tjob03 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 201:300),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre03',
  slurm_options = list(mem = '8G'))

tjob04 <- slurm_call(
  run_bkmr_lg_re, params = list(vector = 301:400),
  global_objects = c('out2_resp1_re'),
  jobname = 'klgre04',
  slurm_options = list(mem = '8G'))
```

```{r}
###########
# stratified bsr, smaller size
###########

out1_resp1_re <- read_rds("sim/sim_resp_sm_re.RDS")

run_bsr_sm_re <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes bsr would stop prematurely...
  # so this code finds the index of the last model run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0
    starting <- min(vector)
  } else {
    final <- max(nums)
    starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out1_resp1_re[[i]]
    
    # for each race level, run bsr
    list_times <- vector(mod = "list", length = 6) 
    list_mods <- vector(mod = "list", length = 6)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      X <- df |> 
        select(As:Sn) |> 
        as.matrix.data.frame()
      C <- df |> 
        select(smoke:bmi) |> 
        as.matrix.data.frame()
      Y <- df$y
      
      # waic for choosing df
      list_times_small <- vector(mode = "list", length = 2)
      
      start.time <- Sys.time()
      mod1 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 1)
      mod2 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 2)
      mod3 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 3)
      mod4 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 4)
      end.time <- Sys.time()
      list_times_small[[1]] <- end.time - start.time
      
      ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- tryCatch({
        NLint(Y = Y, X = X, C = C, 
              nIter = 50000, nBurn = 25000, ns = ind)
      }, error = function(e) {
        NA
      })
      end.time <- Sys.time()
      list_times_small[[2]] <- end.time - start.time
      
      bsr_times[[i]] <- list_times_small
      list_mods[[i]] <- mod
    }
    
    # combine 1-3 r/e
    df <- df_full[df_full$race %in% c(1, 2, 3), ]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |> 
      select(smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # waic for choosing df
    list_times_small <- vector(mode = "list", length = 2)
    
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times_small[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    # fit model and save time
    start.time <- Sys.time()
    mod <- tryCatch({
      NLint(Y = Y, X = X, C = C, 
            nIter = 50000, nBurn = 25000, ns = ind)
    }, error = function(e) {
      NA
    })
    end.time <- Sys.time()
    list_times_small[[2]] <- end.time - start.time
    
    list_times[[6]] <- list_times_small
    list_mods[[6]] <- mod
    
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bsr_sm_", names(out1_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bsr_sm_", names(out1_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  return(bsr_times)
}

# send to hpc
vjob01 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 1:100),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre01',
  slurm_options = list(mem = '8G'))

vjob02 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 101:200),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre02',
  slurm_options = list(mem = '8G'))

vjob03 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 201:300),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre03',
  slurm_options = list(mem = '8G'))

vjob04 <- slurm_call(
  run_bsr_sm_re, params = list(vector = 301:400),
  global_objects = c('out1_resp1_re'),
  jobname = 'ssmre04',
  slurm_options = list(mem = '8G'))
```

```{r}
###########
# stratified bsr, larger size
###########

out2_resp1_re <- read_rds("sim/sim_resp_lg_re.RDS")

run_bsr_lg_re <- function(vector) {
  bsr_times <- vector(mode = "list", length = length(vector))
  
  # create folder for model output
  if(!dir.exists("mods")) {
    dir.create("mods")
  }
  if(!dir.exists("times")) {
    dir.create("times")
  }
  
  # sometimes bsr would stop prematurely...
  # so this code finds the index of the last model run
  list_files <- list.files("mods", full.names = TRUE)
  nums <- as.numeric(sub(".+_(.+)d.+", "\\1", list_files))
  if(length(nums) == 0) {
    final <- 0
    starting <- min(vector)
  } else {
    final <- max(nums)
    starting <- final + 1
  }
  if(file.exists("final.txt")) {
    write(paste0("final ran = ", final, ", starting at ", starting), "final.txt", append = T)
  } else {
    writeLines(paste0("final ran = ", final, ", starting at ", starting), "final.txt")
  }
  
  
  for(i in starting:max(vector)) {
    print(paste0("------------- run ", i, "--------------"))
    
    # prepare data
    df_full <- out2_resp1_re[[i]]
    
    # for each race level, run bsr
    list_times <- vector(mod = "list", length = 6) 
    list_mods <- vector(mod = "list", length = 6)
    
    set.seed(0)
    for(j in 1:5) {
      df <- df_full[df_full$race == j, ]
      X <- df |> 
        select(As:Sn) |> 
        as.matrix.data.frame()
      C <- df |> 
        select(smoke:bmi) |> 
        as.matrix.data.frame()
      Y <- df$y
      
      # waic for choosing df
      list_times_small <- vector(mode = "list", length = 2)
      
      start.time <- Sys.time()
      mod1 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 1)
      mod2 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 2)
      mod3 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 3)
      mod4 <- NLint(Y = Y, X = X, C = C, 
                    nIter = 5000, nBurn = 2500, ns = 4)
      end.time <- Sys.time()
      list_times_small[[1]] <- end.time - start.time
      
      ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
      
      # fit model and save time
      start.time <- Sys.time()
      mod <- tryCatch({
        NLint(Y = Y, X = X, C = C, 
              nIter = 50000, nBurn = 25000, ns = ind)
      }, error = function(e) {
        NA
      })
      end.time <- Sys.time()
      list_times_small[[2]] <- end.time - start.time
      
      bsr_times[[i]] <- list_times_small
      list_mods[[i]] <- mod
    }
    
    # combine 1-3 r/e
    df <- df_full[df_full$race %in% c(1, 2, 3), ]
    X <- df |> 
      select(As:Sn) |> 
      as.matrix.data.frame()
    C <- df |> 
      select(smoke:bmi) |> 
      as.matrix.data.frame()
    Y <- df$y
    
    # waic for choosing df
    list_times_small <- vector(mode = "list", length = 2)
    
    start.time <- Sys.time()
    mod1 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 1)
    mod2 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 2)
    mod3 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 3)
    mod4 <- NLint(Y = Y, X = X, C = C, 
                  nIter = 5000, nBurn = 2500, ns = 4)
    end.time <- Sys.time()
    list_times_small[[1]] <- end.time - start.time
    
    ind <- which.min(c(mod1$waic, mod2$waic, mod3$waic, mod4$waic))
    
    # fit model and save time
    start.time <- Sys.time()
    mod <- tryCatch({
      NLint(Y = Y, X = X, C = C, 
            nIter = 50000, nBurn = 25000, ns = ind)
    }, error = function(e) {
      NA
    })
    end.time <- Sys.time()
    list_times_small[[2]] <- end.time - start.time
    
    list_times[[6]] <- list_times_small
    list_mods[[6]] <- mod
    
    # save model and remove from memory
    write_rds(list_mods, file = 
                paste0("mods/bsr_lg_", names(out2_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    write_rds(list_times, file = 
                paste0("times/bsr_lg_", names(out2_resp1_re)[i], "_", i, 
                       "df", ind, ".RDS"))
    
    rm(mod1, mod2, mod3, mod4, mod)
  }
  
  # write_rds(bsr_times, file = "bsr_lgf_times.RDS")
  return(bsr_times)
}

# send to hpc
wjob01 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 1:100),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre01',
  slurm_options = list(mem = '8G'))

wjob02 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 101:200),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre02',
  slurm_options = list(mem = '8G'))

wjob03 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 201:300),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre03',
  slurm_options = list(mem = '8G'))

wjob04 <- slurm_call(
  run_bsr_lg_re, params = list(vector = 301:400),
  global_objects = c('out2_resp1_re'),
  jobname = 'slgre04',
  slurm_options = list(mem = '8G'))

```



### Code for Section \@ref(results):

Here, we extract results from our simulation. We use the `rslurm`, `bkmr`, and `NLinteraction` packages in this section. This code was run on the Amherst HPC RStudio server. 

### Code for Appendix \@ref(appa):

Here, we create the supplemental output that is included in Appendix \@ref(appa). 

First, we visualize relationships between significant univariate exposures and the response. 

```{r}
library(tidyverse)

p1 <- ggplot(NULL) +
  geom_function(fun = function(x) x, 
                color = "darkorchid1") +
  xlim(-2, 2) +
  labs(x = "Hg")

p2 <- ggplot(NULL) +
  geom_function(fun = function(x) 3/(1+exp(-4*x)), 
                color = "deepskyblue3") +
  xlim(-2, 2) +
  labs(x = "Ni")

p3 <- ggplot(NULL) +
  geom_function(fun = function(x) 1.5/(1+exp(-4*x)), 
                color = "darkorange") +
  xlim(-2, 2) +
  labs(x = "Sn")

p4 <- ggplot(NULL) +
  geom_function(fun = function(x) (x^2) + 0.5*x, 
                color = "coral1") +
  xlim(-2, 2) +
  labs(x = "Sb")

cowplot::plot_grid(p1, p2, p3, p4)
ggsave("index/figures/univariatelines.png", width = 6, height = 4)
```

Next, we visualize 3D surfaces for pair-wise interactions between exposures. 

```{r}
# load packages
library(tidyverse)
library(plotly)
# use reticulate to save plotly 3d plots
if(!require(reticulate)) {
  install.packages('reticulate')
  reticulate::install_miniconda()
  reticulate::conda_install('r-reticulate', 'python-kaleido')
  reticulate::conda_install('r-reticulate', 'plotly', channel = 'plotly')
  Sys.setenv(RETICULATE_PYTHON = 
               '/Users/elizabethzhang/Library/r-miniconda-arm64/envs/r-reticulate/bin/python')
  reticulate::use_miniconda('r-reticulate')
}
```


```{r}
# load in observed data
comb_small <- read_csv("madres_data/base_data.csv")

# log-transform and scale target data
comb_scale <- comb_small |> 
  mutate(across(10:19, ~scale(log(.)))) 

# check ranges of scaled predictors
range(comb_scale$Hg)
range(comb_scale$Ni)
range(comb_scale$Cd)
range(comb_scale$As)
range(comb_scale$Co)

# generate data covering 2d predictor surface
data <- expand.grid(x1 = seq(-3, 3, by = 0.1), 
                    x2 = seq(-3, 3, by = 0.1))
x1 <- data$x1
x2 <- data$x2

# function to create plot
create_plot <- function(xax, yax, Y, xname = NA, yname = NA) {
  plot_ly(x = ~xax, y = ~yax, z = ~Y, intensity = ~Y) |> 
    add_trace(type = "mesh3d") |> 
    layout(scene = list(
      xaxis = list(rangemode = "normal",
                   showgrid = FALSE,
                   showline = TRUE, 
                   mirror = TRUE, 
                   ticks = "outside", 
                   title = xname), 
      yaxis = list(rangemode = "normal", 
                   showgrid = FALSE,
                   showline = TRUE, 
                   mirror = TRUE, 
                   ticks = "outside", 
                   title = yname), 
      zaxis = list(rangemode = "normal", 
                   showgrid = FALSE,
                   showline = TRUE, 
                   mirror = TRUE, 
                   ticks = "outside", 
                   title = "Y"), 
      aspectmode = "cube"
    ))
}

##########
# marginally significant (Hg and Ni)
##########

# no interaction
y00 <- with(data, x1 + 3/(1+exp(-4*x2))) 
fig00 <- create_plot(x1, x2, y00, "Hg", "Ni")  |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = 0.1))))
fig00
save_image(fig00, "index/figures/surfaces/p00.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, smaller effect size
yam1 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.35*x1*x2) 
figam1 <- create_plot(x1, x2, yam1, "Hg", "Ni") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figam1
save_image(figam1, "index/figures/surfaces/am1.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, larger effect size
yam2 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.75*x1*x2) 
figam2 <- create_plot(x1, x2, yam2, "Hg", "Ni") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figam2
save_image(figam2, "index/figures/surfaces/am2.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, smaller effect size
yap1 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.13*x1*((x2-1)^2))
figap1 <- create_plot(x1, x2, yap1, "Hg", "Ni")|> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figap1
save_image(figap1, "index/figures/surfaces/ap1.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, larger effect size
yap2 <- with(data, x1 + 3/(1+exp(-4*x2)) + 0.26*x1*((x2-1)^2))
figap2 <- create_plot(x1, x2, yap2, "Hg", "Ni") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figap2
save_image(figap2, "index/figures/surfaces/ap2.png", 
           width = 720, height = 480, scale = 3)

##########
# marginally insignificant (Cd and As)
##########

# multiplicative interaction, smaller effect size
ybm1 <- with(data, 0.35*x1*x2) 
figbm1 <- create_plot(x1, x2, ybm1, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbm1
save_image(figbm1, "index/figures/surfaces/bm1.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, larger effect size
ybm2 <- with(data, 0.7*x1*x2) 
figbm2 <- create_plot(x1, x2, ybm2, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbm2
save_image(figbm2, "index/figures/surfaces/bm2.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, smaller effect size
ybp1 <- with(data, 0.125*x1*((x2-1)^2)) 
figbp1 <- create_plot(x1, x2, ybp1, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbp1
save_image(figbp1, "index/figures/surfaces/bp1.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, larger effect size
ybp2 <- with(data, 0.25*x1*((x2-1)^2))
figbp2 <- create_plot(x1, x2, ybp2, "Cd", "As") |> 
  layout(scene = list(camera = list(eye = list(x = 1.4, y = 1.4, z = 1.2))))
figbp2
save_image(figbp2, "index/figures/surfaces/bp2.png", 
           width = 720, height = 480, scale = 3)

##########
# highly correlated (Ni and Co)
##########

# multiplicative interaction, smaller effect size
ycm1 <- with(data, 3/(1+exp(-4*x2)) + 0.3*x1*x2) 
figcm1 <- create_plot(x1, x2, ycm1, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.2, y = 1.2, z = 1.5))))
figcm1
save_image(figcm1, "index/figures/surfaces/cm1.png", 
           width = 720, height = 480, scale = 3)

# multiplicative interaction, larger effect size
ycm2 <- with(data, 3/(1+exp(-4*x2)) + 0.6*x1*x2) 
figcm2 <- create_plot(x1, x2, ycm2, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.2, y = 1.2, z = 1.5))))
figcm2
save_image(figcm2, "index/figures/surfaces/cm2.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, smaller effect size
ycp1 <- with(data, 3/(1+exp(-4*x2)) + 0.1*x1*((x2-1)^2))
figcp1 <- create_plot(x1, x2, ycp1, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figcp1
save_image(figcp1, "index/figures/surfaces/cp1.png", 
           width = 720, height = 480, scale = 3)

# polynomial interaction, larger effect size
ycp2 <- with(data, 3/(1+exp(-4*x2)) + 0.2*x1*((x2-1)^2))
figcp2 <- create_plot(x1, x2, ycp2, "Ni", "Co") |> 
  layout(scene = list(camera = list(eye = list(x = 1.5, y = 1.5, z = .1))))
figcp2
save_image(figcp2, "index/figures/surfaces/cp2.png", 
           width = 720, height = 480, scale = 3)
```

Next, we look at simulated exposure and covariate data for the larger size dataset. We also create the grid of density plots for Spearman's correlation values between exposures in the simulated smaller size datasets. 

```{r}
# create density plot of correlation for smaller size dataset
# read small size back in
out1 <- read_rds("sim/sim_preds_sm.RDS")

# extract correlation
cors <- out1 |> 
  purrr::map_df(\(x) {
    cor_mat <- cor(x[, 5:14], method = "spearman")
    cor_mat[lower.tri(cor_mat)] <- NA
    melt_cor <- reshape2::melt(cor_mat) |> 
      mutate(value = ifelse(value == 1, NA, value)) |> 
      na.omit() |> 
      mutate(sim = x$sim[1])
    return(melt_cor)
  })

# function for plotting x-axis
newbreaks <- function(lims) {
  range <- diff(lims)
  return(c(lims[1] + range/5, mean(lims), lims[2] - range/5))
}

# create grid of density plots
cors_dens <- cors |> 
  group_by(Var1, Var2) |> 
  mutate(mean = mean(value)) |> 
  ungroup() |> 
  ggplot(aes(x = value, fill = mean)) +
  geom_density() + 
  scale_x_continuous(breaks = newbreaks, 
                     labels = ~round(.x, 2)) +
  scale_y_continuous(position = "right") +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  ggh4x::facet_grid2(fct_rev(Var2) ~ Var1, scales = "free", independent = "x", 
                     render_empty = FALSE, switch = "both") +
  labs(x = TeX(r"( Spearman's $\rho$ )")) +
  theme(strip.placement = "outside", 
        strip.text.y.left = element_text(angle = 0), 
        legend.justification = c(1, 0),
        legend.position = c(0.9, 0.1),
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))
cors_dens

ggsave("index/figures/ch4_corr_sim.png", width = 10, height = 7)
```


```{r}
#############
# look at simulated data, larger size
#############

# read larger size data back in
out2 <- read_rds("sim/sim_preds_lg.RDS")
comb_sim2 <- bind_rows(out2)
```


```{r}
# density plots for exposures
name_order <- c("As", "Cd", "Co", "Hg", "Ni", "Tl", "Pb", "Mo", "Sb", "Sn")
comb_sim2 |> 
  mutate(sim = as.factor(sim)) |> 
  select(5:15) |> 
  pivot_longer(cols = 1:10) |>
  mutate(name = factor(name, levels = name_order)) |> 
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  # reference observed densities
  geom_density(
    data = comb_log |> select(10:19) |> pivot_longer(cols = 1:10) |> 
      mutate(name = factor(name, levels = name_order)),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free")
# save
ggsave("index/figures/ch4_univ_exp_sim_lg.png", width = 6, height = 4)
```


```{r}
# density plot for continuous covariates
cov_sim_p2 <- comb_sim2 |> 
  mutate(sim = as.factor(sim)) |> 
  select(age, bmi, sim) |> 
  pivot_longer(cols = 1:2) |>
  ggplot(aes(x = value, group = sim)) +
  geom_line(stat = "density", color = "grey10", alpha = 0.01) + 
  geom_density(
    data = comb_log |> select(age, bmi) |> pivot_longer(cols = 1:2),
    mapping = aes(x = value), 
    color = "deepskyblue", linewidth = 0.75, inherit.aes = FALSE
  ) +
  facet_wrap(~name, scales = "free", ncol = 1)

# bar + violin plot for continuous covariates
cov_sim_q2 <- comb_sim2 |> 
  mutate(sim = as.factor(sim)) |> 
  select(sim, smoke, race) |> 
  mutate(smoke = ifelse(smoke == 0, "Never-exposed", "Ever-exposed"), 
         race = case_when(
           race == 1 ~ "Non-Hisp. white", 
           race == 2 ~ "Non-Hisp. black", 
           race == 3 ~ "Non-Hisp. other", 
           race == 4 ~ "Hispanic born\nin US", 
           race == 5 ~ "Hispanic born\noutside US"
         )) |> 
  pivot_longer(cols = 2:3) |> 
  group_by(sim, name, value) |> 
  summarize(prop = n()/1000) |> 
  mutate(value = factor(
    value, levels = rev(c("Never-exposed", "Ever-exposed",
                          "Non-Hisp. white", "Non-Hisp. black", "Non-Hisp. other", 
                          "Hispanic born\nin US", "Hispanic born\noutside US"))
  )) |> 
  ggplot(aes(x = value, y = prop)) +
  geom_bar(data = df_forcovcat, aes(x = value, y = after_stat(prop), group = 1), 
           inherit.aes = FALSE, stat = "count", fill = "skyblue") +
  geom_violin(color = "gray30", fill = "gray", alpha = 0.25) + 
  facet_wrap(~name, scales = "free", ncol = 1) +
  coord_flip() +
  labs(x = NULL, y = "proportion")

# plot in grid and save
cowplot::plot_grid(cov_sim_p2, cov_sim_q2, labels = "auto", nrow = 1, 
                   rel_widths = c(0.4, 0.6))
ggsave("index/figures/ch4_univ_cov_sim_lg.png", width = 6, height = 4)
```


```{r}
# extract spearman's correlation from large simulated data
corl <- out2 |> 
  purrr::map_df(\(x) {
    cor_mat <- cor(x[, 5:14], method = "spearman")
    cor_mat[lower.tri(cor_mat)] <- NA
    melt_cor <- reshape2::melt(cor_mat) |> 
      mutate(value = ifelse(value == 1, NA, value)) |> 
      na.omit() |> 
      mutate(sim = x$sim[1])
    return(melt_cor)
  })

# grid of density plots of correlation in large simulated data
cors_dens2 <- corl |> 
  group_by(Var1, Var2) |> 
  mutate(mean = mean(value)) |> 
  ungroup() |> 
  ggplot(aes(x = value, fill = mean)) +
  geom_density() + 
  scale_x_continuous(breaks = newbreaks, 
                     labels = ~round(.x, 2)) +
  scale_y_continuous(position = "right") +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  ggh4x::facet_grid2(fct_rev(Var2) ~ Var1, scales = "free", independent = "x", 
                     render_empty = FALSE, switch = "both") +
  labs(x = TeX(r"( Spearman's $\rho$ )")) +
  theme(strip.placement = "outside", 
        strip.text.y.left = element_text(angle = 0), 
        legend.justification = c(1, 0),
        legend.position = c(0.9, 0.1),
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))

# heatmap of average correlation in large simulated data
cor_sim2 <- corl |> 
  group_by(Var1, Var2) |> 
  summarize(value = mean(value)) |> 
  mutate(label = round(value, 2)) |> 
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = label), size = 3.5) +
  scale_fill_gradient2(
    limit = c(-0.6, 0.6), breaks = c(-0.6, -0.3, 0, 0.3, 0.6),
    low = "deepskyblue3", mid = "white", high = "darkorange", 
    na.value = NA) +
  coord_fixed() +
  labs(x = NULL, y = NULL, fill = TeX(r"( Mean Spearman's $\rho$ )")) +
  theme(
    panel.grid.major.x = element_line(color = "grey85",
                                      linewidth = 0.25,
                                      linetype = 2), 
    panel.border = element_blank(),
    legend.justification = c(1, 0),
    legend.position = c(0.9, 0.1),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))

# put original and simulated correlation heatmaps together
top_row2 <- cowplot::plot_grid(cor_orig, cor_sim2, labels = "auto", label_size = 16, 
                              nrow = 1, scale = 0.95)
# put original, simulated, and density plots of correlation together
cowplot::plot_grid(top_row2, cors_dens2, labels = c("", "c"), label_size = 16, 
                   nrow = 2, rel_heights = c(5, 7), scale = c(1, 0.95))
ggsave("index/figures/ch4_corr_lg_simorigdens.png", width = 10, height = 12)
```

Here, we create the visualization of $R^2$ values in multiple linear regressions with the true functional form of the chemicals specified, in order to ensure we are achieving a realistic signal-to-noise ratio. This code was run on the Amherst HPC RStudio server. 

```{r}
### smaller size

# read in simulated datasets
out1_resp1 <- read_rds("sim/sim_resp_sm_a.RDS")
run_co_sm <- function() {
  # initialize vectors
  chems_oracle <- vector(mode = 'list', length = 1700) 
  names(chems_oracle) <- names(out1_resp1)
  
  for(i in 1:1700) {
    df <- out1_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    if(i <= 100) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + 
                                I(1/(1+exp(-4*Sn))), data = df)
    } else if (i <= 300) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg*Ni, data = df)
    } else if (i <= 500) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)), data = df)
    } else if (i <= 700) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Cd*As, data = df)
    } else if (i <= 900) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Cd*((As-1)^2)), data = df)
    } else if (i <= 1100) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Ni*Co, data = df)
    } else if (i <= 1300) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Ni*((Co-1)^2)), data = df)
    } else if (i <= 1500) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg:Ni:Tl, data = df)
    } else if (i <= 1700) {
      chems_oracle[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)*Tl), data = df)
    }
  }
  return(chems_oracle)
}

# send to hpc
cosjob <- slurm_call(
  run_mlr_sm, 
  global_objects = c('out1_resp1'),
  jobname = 'co_sm')

# get output
chem_oracle <- get_slurm_out(cosjob)
write_rds(chem_oracle, "sim/chem_oracle_sm.RDS")

### larger sample size

# read in simulated datasets
out2_resp1 <- read_rds("sim/sim_resp_lg_a.RDS")

run_co_lg <- function() {
  # initialize vectors
  chems_onlyl <- vector(mode = 'list', length = 1700)
  names(chems_onlyl) <- names(out2_resp1)
  chems_oraclel <- vector(mode = 'list', length = 1700) 
  names(chems_oraclel) <- names(out2_resp1)
  
  for(i in 1:1700) {
    df <- out2_resp1[[i]] |> 
      mutate(race = as.factor(race), smoke = as.factor(smoke)) |> 
      select(-sim)
    
    if(i <= 100) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + 
                                I(1/(1+exp(-4*Sn))), data = df)
    } else if (i <= 300) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg*Ni, data = df)
    } else if (i <= 500) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)), data = df)
    } else if (i <= 700) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Cd*As, data = df)
    } else if (i <= 900) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Cd*((As-1)^2)), data = df)
    } else if (i <= 1100) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Ni*Co, data = df)
    } else if (i <= 1300) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Ni*((Co-1)^2)), data = df)
    } else if (i <= 1500) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                Hg:Ni:Tl, data = df)
    } else if (i <= 1700) {
      chems_oraclel[[i]] <- lm(y ~ Hg + Sb +
                                I(1/(1+exp(-4*Ni))) + I(Sb^2) + I(1/(1+exp(-4*Sn))) +
                                I(Hg*((Ni-1)^2)*Tl), data = df)
    }
  }
  return(chems_oraclel)
}

# send to hpc
coljob <- slurm_call(
  run_co_lg, 
  global_objects = c('out2_resp1'),
  jobname = 'co_lg')

# get output
chem_oraclel <- get_slurm_out(coljob)
write_rds(chem_oraclel, "sim/chem_oracle_lg.RDS")
```


```{r}
# extract rsq from smaller size datasets
chem_mods <- read_rds("sim/mlr/chem_oracle_sm.RDS")
rsq_chem <- chem_mods |> 
  purrr::map_df(\(x) {
    data.frame(
      rsq = summary(x)$r.squared
    )
  }) |> 
  mutate(name = names(chem_mods))

# plot for smaller size
rsqsmplot <- rsq_chem |> 
  ggplot(aes(x = rsq)) +
  geom_density() + 
  facet_wrap(~name, 
             labeller = as_labeller(appender1, 
                                    default = label_parsed), 
             ncol = 4) +
  labs(y = "Density", x = latex2exp::TeX("R$^2$"))

# extract rsq from larger size datasets
chem_modl <- read_rds("sim/mlr/chem_oracle_lg.RDS")
rsq_cheml <- chem_modl |> 
  purrr::map_df(\(x) {
    data.frame(
      rsq = summary(x)$r.squared
    )
  }) |> 
  mutate(name = names(chem_modl))

# plot for larger size
rsqlgplot <- rsq_cheml |> 
  ggplot(aes(x = rsq)) +
  geom_density() + 
  facet_wrap(~name, 
             labeller = as_labeller(appender1, 
                                    default = label_parsed), 
             ncol = 4) +
  labs(y = "Density", x = latex2exp::TeX("R$^2$"))

# plot both in grid and save
cowplot::plot_grid(rsqsmplot, rsqlgplot, labels = "auto", nrow = 1)
ggsave("index/figures/chem_rsq.png", width = 12, height = 6)
```

We also look at selecting degrees of freedom in BSR using 5,000 vs. 50,000 MCMC iterations. Refer to the code for fitting BSR on the smaller size datasets for how the models for this test were run. 

```{r}
# extract names of files for 50,000 iterations
main_folder <- "sim/bsr_df_sm"
subfolders <- list.dirs(main_folder, full.names = TRUE, recursive = TRUE)
mod_subfolders <- subfolders[grepl("mods", subfolders)]
mod_labels <- gsub("\\D", "", mod_subfolders)
mod_labels <- ifelse(mod_labels == "", 1, as.numeric(mod_labels))

mod_paths <- mod_subfolders |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = mod_labels)

# extract WAIC values from model output
waic <- names(mod_paths) |> 
  purrr::map_df(\(x) {
    mod_paths[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- data.frame(
          df = c(1, 2, 3, 4, 5), 
          waic = c(bsr[[1]]$waic, 
                   bsr[[2]]$waic, 
                   bsr[[3]]$waic, 
                   bsr[[4]]$waic, 
                   bsr[[5]]$waic), 
          trial = rep(substr(y, nchar(y) - 4, nchar(y) - 4))
        )
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })

write_csv(waic, "sim/tables/test_waic.csv")

# look at waic values
waic <- read_csv("sim/tables/test_waic.csv")

# select degrees of freedom that minimizes waic
min_waic <- waic |> 
  group_by(case, trial) |> 
  filter(waic == min(waic)) |> 
  arrange(as.numeric(case))

# extract names of files for 5,000 iterations (trial 2)
main_folder2 <- "sim/bsr_df_sm2"
subfolders2 <- list.dirs(main_folder2, full.names = TRUE, recursive = TRUE)
mod_subfolders2 <- subfolders2[grepl("mods", subfolders2)]
mod_labels2 <- gsub("\\D", "", substr(mod_subfolders2, 16, nchar(mod_subfolders2)))
mod_labels2 <- ifelse(mod_labels2 == "", 1, as.numeric(mod_labels2))

mod_paths2 <- mod_subfolders2 |> 
  purrr::map(\(x) {
    list.files(x, full.names = TRUE)
  }) |> 
  setNames(nm = mod_labels2)

# extract waic from model outputs
waic2 <- names(mod_paths2) |> 
  purrr::map_df(\(x) {
    mod_paths2[[x]] |> 
      purrr::map_df(\(y) {
        bsr <- read_rds(y)
        result <- data.frame(
          df = c(1, 2, 3, 4, 5), 
          waic = c(bsr[[1]]$waic, 
                   bsr[[2]]$waic, 
                   bsr[[3]]$waic, 
                   bsr[[4]]$waic, 
                   bsr[[5]]$waic), 
          trial = rep(substr(y, nchar(y) - 4, nchar(y) - 4))
        )
        rm(bsr)
        return(result)
      }) |> 
      mutate(case = x)
  })

write_csv(waic2, "sim/tables/test_waic2.csv")

# compare them
waic <- read_csv("sim/tables/test_waic.csv")
waic2 <- read_csv("sim/tables/test_waic2.csv")
waic_comb <- waic |> 
  mutate(iter = 1) |> 
  bind_rows(mutate(waic2, iter = 2))

# create plot
waic_comb |> 
  filter(trial <= 5) |> 
  mutate(df = as.factor(df), 
         iter = factor(ifelse(iter == 1, "F", "P"), levels = c("P", "F"))) |> 
  ggplot(aes(x = iter, y = waic, color = df)) +
  geom_point() +
  geom_line(aes(group = df)) + 
  ggh4x::facet_grid2(paste0("Trial ", trial) ~ case, 
                     scales = "free_y", independent = "y") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(), 
        plot.caption = element_text(hjust = 0, size = 7)) +
  labs(y = "WAIC", x = "# MCMC iterations (F = 50,000, P = 5,000)", 
       color = "Degrees\nfreedom",
       caption = paste0(
         "Scenarios are labelled in the top strip as follows:\n", 
         "1 = base case; 2 = HgNi mult. small; 3 = HgNi mult. large; ", 
         "4 = HgNi poly. small; 5 = HgNi poly. large; ", 
         "6 = CdAs mult. small; 7 = CdAs mult. large;", 
         "8 = CdAs poly. small; 9 = CdAs poly. large;\n", 
         "10 = NiCo mult. small; 11 = NiCo mult. large; ", 
         "12 = NiCo poly. small; 13 = NiCo poly. large; ", 
         "14 = HgNiTl mult. small; 15 = HgNiTl mult. large; ", 
         "16 = HgNiTl poly. small; 17 = HgNiTl poly. large"))

ggsave("index/figures/test_waic2.png", height = 6, width = 9)

# get proportion of correctly selected df's
waic_min <- waic_comb |> 
  mutate(iter = ifelse(iter == 1, "full", "partial")) |> 
  arrange(iter, case, trial) |> 
  filter(trial <= 5) |> 
  group_by(iter, trial, case) |> 
  filter(waic == min(waic)) |> 
  ungroup() |> 
  pivot_wider(id_cols = c(trial, case), 
              names_from = iter, values_from = df) |> 
  mutate(equal = (full == partial))
mean(waic_min$equal)  
```




